<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">GraphQL | MOZI</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://team-yaza.github.io/blog/GraphQL"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="GraphQL | MOZI"><meta data-rh="true" name="description" content="Intro"><meta data-rh="true" property="og:description" content="Intro"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-08-31T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/hyunjinee"><meta data-rh="true" property="article:tag" content="GraphQL,MOZI"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://team-yaza.github.io/blog/GraphQL"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog/GraphQL" hreflang="en"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog/GraphQL" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="MOZI RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="MOZI Atom Feed"><link rel="stylesheet" href="/assets/css/styles.b2d9e02d.css">
<link rel="preload" href="/assets/js/runtime~main.9f7dceef.js" as="script">
<link rel="preload" href="/assets/js/main.746c5878.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">MOZI</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/dnd">Drag And Drop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mozi-calendar">📅 캘린더 만들기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/thinking-in-react">Thinking in React</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/GraphQL">GraphQL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/useState-vs-useRef">useState vs useRef</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/offline-first">서비스 워커로 오프라인 우선 받아들이기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/life-cycle-and-cache-controll">서비스워커의 생명 주기와 캐시 관리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/웹은-어떻게-발전했는가">웹은 어떻게 발전했는가</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-cache-storage-api">CacheStorage API 사용하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-service-worker">서비스워커 사용해보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/What-is-PWA">PWA(Progressive Web App)란 무엇인가?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/rendering-patterns">Rendering Patterns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/welcome">MOZI</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mdx-blog-post">MDX Blog Post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/first-blog-post">First Blog Post</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">GraphQL</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-08-31T00:00:00.000Z" itemprop="datePublished">August 31, 2022</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e254c4ee-c148-4722-8fa9-a98de1baca87/image.png" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="intro">Intro<a class="hash-link" href="#intro" title="Direct link to heading">​</a></h2><blockquote><p>소프트웨어 마에스트로 컨퍼런스 발표(8.31) 내용을 요약한 글 입니다.</p></blockquote><p>안녕하세요. 소프트웨어 마에스트로 연수생 이현진입니다.</p><p>이번 발표에서는 GraphQL의 컨셉, REST API와의 차이, 실제 활용 실습과 더 나아가 React에서 GraphQL이 해결할 수 있는 문제에 대해서 이야기해보도록 하겠습니다.</p><p><code>발명은 필요에의해서 시작됩니다.</code>
페이스북이 그래프QL을 만들기로한 이유는 다음과 같습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/844a29e7-d31a-49ed-8900-6514332b04a4/image.png" class="img_ev3q"></p><ol><li>모바일 사용량의 증가로 효율적인 데이터 로딩이 필요(저전력 장치 및 느린 네트워크 문제)</li><li>다양한 플랫폼(플랫폼의 다양화로 인해 모든 요구 사항에 맞는 하나의 API를 구축하고 유지관리하기 어려움)</li><li>빠른 기능 개발에 대한 기대(지속적 배포는 업계의 표준이 되었고 빠른 반복과 빈번한 제품 배포는 필수적이고 이에따라, <code>프론트엔드와 백엔드의 의사소통 비용은 증가</code>)</li></ol><p>이런 문제들을 해결하기위한 방법은 뭘까요? 각각 대응시켜보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ee6d3f15-3988-402f-9833-ce1c401eaeff/image.png" class="img_ev3q"></p><ol><li><code>필요한 데이터</code>만 <code>한번에</code>, <code>정확하게</code> 요청한다.</li><li>엔드포인트를 <code>통합</code>한다.</li><li>프론트엔드와 백엔드의 <code>커뮤니케이션을 줄이고</code> 개발에 집중한다.</li></ol><p>이 해결 방법이 곧 <code>GraphQL</code>입니다.
이제 GraphQL이 어떻게 이 문제들을 해결했는지 알아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3b86bb70-ddda-43b2-8cb2-4db48e7337ed/image.png" class="img_ev3q"></p><p>GraphQL은 Facebook에서 개발한 오픈소스 언어로 현실 세계의 데이터를 표현하는 가장 적합한 방법이 <code>Graph</code>라는 사실에 착안합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c5d065cd-1731-481a-931c-1688741e2941/image.png" class="img_ev3q"></p><p>사람들은 다른 사람들과 관계를 맺으며 살아갑니다. 가족, 친구, 동료와 사회적 관계를 맺고 있습니다. 이러한 관계중 일부는 겹치지만 겹치지 않는 관계도 존재합니다. 우리 모두는 각자의 삶 내에서 연결된 관계 그래프를 지닙니다.</p><p>GraphQL이 API 개발에서 해결하려고 하는 문제가 이렇게 서로 <code>연결된 데이터</code>입니다. GraphQL API는 데이터를 효율적으로 연결할 수 있으며, 요청의 수와 복잡성을 줄이고 클라이언트가 정확히 필요로하는 데이터를 제공할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3908ea9f-d0aa-4365-8dcf-8b4fc43b7bb4/image.png" class="img_ev3q"></p><p>GraphQL은 두가지 의미로 해석될 수 있습니다.</p><ol><li>GraphQL은 API를 위한 <code>Query Language</code>이다.</li><li>GraphQL은 서버사이드에서 실행되는 쿼리를 해석하는 <code>Runtime</code>이다.</li></ol><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3a9b90c4-71b8-4d16-b016-117c89c80fe8/image.png" class="img_ev3q"></p><p><code>Query Language</code>는 데이터베이스 또는 데이터 관리 시스템에 접근하기 위한 언어로 대표적으로 <code>SQL</code>을 들 수 있습니다.</p><p><code>SQL</code>이 데이터베이스에 질의를 하는 언어인 반면에, <code>GQL</code>은 클라이언트에서 API에게 질의를 하는 언어입니다.
따라서 GraphQL은 데이터베이스의 종류에 구애받지 않고 API가 사용되는 모든 컨텍스트에서 효과적으로 사용할 수 있습니다.</p><p>GraphQL은 백엔드 입장에서 구현돼야할 <code>Runtime</code>이기도 합니다.</p><p>API 사용자는 GraphQL 언어를 사용해서 필요한 데이터를 정확하게 요구하기 위한 텍스트를 구성하고 클라이언트는 이 텍스트 요청을 전송채널(예:HTTPS)를 통해 API 서비스에 전달합니다. 그러면 GraphQL Runtime 계층이 이 텍스트 요청을 받아서 백엔드에 있는 다른 서비스들과 커뮤니케이션하고 그 결과들을 모아서 적합한 데이터를 만듭니다. 그렇게 만들어진 데이터를 JSON과 같은 형식으로 API 사용자에게 반환하는 것 입니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="graphql-vs-rest">GraphQL vs REST<a class="hash-link" href="#graphql-vs-rest" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4c3b4ff4-49bc-4bb3-b119-4b1faf4f8956/image.png" class="img_ev3q"></p><p>API는 데이터가 데이터베이스에서 애플리케이션으로 흐르는 인터페이스를 제공합니다.
즉, API의 사용자는 서버가 어떤 언어로 만들어져있는지, 데이터베이스는 어떤 것을 쓰는지 신경쓸 필요가 없고 우리가 중요하다고 생각하는 것에 집중할 수 있도록 도와줍니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6b3851b8-46ce-4bb4-bfa1-c3dd3ec4cb76/image.png" class="img_ev3q"></p><p>현대의 많은 애플리케이션은 REST API로 구성되어있습니다. REST 형식의 API는 URL 구조와 쿼리 매개변수를 사용하여 서버에 요청합니다.
REST API는 URL과 요청 METHOD를 조합하기 때문에 다양한 Endpoint가 존재합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d7edb728-9ee3-4cd0-a2cb-bcb4ac2b27df/image.png" class="img_ev3q"></p><p>블로그 애플리케이션을 렌더링하는 것을 예로 들어보겠습니다.</p><p>블로그 애플리케이션은 크게 Posts, Profile, Followers 컴포넌트로 이루어져 있고 각각은 하나의 REST API Endpoint에 매핑됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e70c8ff6-e06d-4fac-9f39-9196d9da3023/image.png" class="img_ev3q"></p><p>REST API에서는 URL이 자원을 나타내기 때문에 세가지 각기 다른 네트워크 요청을 보내야만 자원을 가져올 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3d8cc27f-dc95-4530-8b1f-c250b4a64a9c/image.png" class="img_ev3q"></p><p>반면 GraphQL은 이 3개의 네트워크 요청을 단 하나의 요청으로 통합할 수 있습니다.</p><p>왼쪽 위가 GraphQL로 작성한 쿼리문이고 오른쪽 아래가 응답 데이터입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e5e67f36-c35d-423c-8ad9-098102f890e8/image.png" class="img_ev3q"></p><p>GraphQL 쿼리와 응답 내용의 구조는 상당히 직관적입니다. 요청하는 쿼리문의 구조와 응답의 구조는 거의 일치합니다.</p><p>또한 user와 연결되어있는 posts와 followers 같은 리소스들을 하나의 요청으로 처리할 수 있습니다.</p><p>이런 GraphQL의 특징을 <code>선언적 data fetching</code>이라고 합니다.
자신이 선언한 쿼리 내용대로 데이터를 받아올 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/33c45aa9-a442-4cd6-8e0e-fe5b1229c57c/image.png" class="img_ev3q"></p><p>예제를 통해 알 수 있는 REST API의 문제는 두가지입니다.</p><p>첫째, <code>Overfetching</code>. REST API의 특성상 데이터를 주고받을 때 클라이언트에서 활용하지 않는 필요없는 데이터까지 주고받을 확률이 높습니다. 따라서 이는 불필요한 리소스 낭비를 초래합니다.</p><p>둘째, <code>Underfetching</code>. 필요한 데이터를 만들기 위해 여러번의 API 호출이 필요합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ca36db41-2f05-4ecb-b2c8-148ed73c0b0c/image.png" class="img_ev3q"></p><p>이를 통해 GraphQL이 가지는 이점은 명확합니다.</p><p><code>여러개의 엔드포인트가 아닌 하나의 엔드포인트를 만들고 한번의 요청으로 원하는 정보만를 얻는다. 즉 Overfetching과 Underfetching 문제를 해결한다.</code></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9f4ba80d-d790-4879-8383-c415e4b3a0c7/image.png" class="img_ev3q"></p><p>예시를 통해 GraphQL과 REST를 비교해보면 글의 초반부에 소개드렸던 REST API의 문제점 두가지를 해결해준다는 것을 알 수 있습니다.</p><ol><li>효율적인 데이터 로딩이 필요 -&gt; 한번의 요청으로 원하는 데이터만 받아옴.</li><li>다양한 플랫폼 지원 -&gt; 원하는 데이터의 형식을 클라이언트 측에서 결정할 수 있음.</li></ol><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/15c09e1a-e026-4ea2-bebc-07a20ab352c5/image.png" class="img_ev3q"></p><p>마지막 문제인 Communication 문제는 어떻게 해결할까요?</p><p>REST API의 문제였던 프론트엔드와 백엔드의 <code>커뮤니케이션 비용 문제</code>를 GraphQL이 어떻게 해결하는지 알아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/68db19d3-5f7e-41ef-8129-960293f5132e/image.png" class="img_ev3q"></p><p>보통 REST API는 서버에서 데이터를 내려준대로 활용합니다.(<code>Fixed Data Structures</code>)
신기한 점은 GraphQL은 클라이언트에서 가져올 데이터를 선언할 수 있다는 점입니다.</p><p>어떻게 선언적으로 데이터를 가져올 수 있을까요?
데이터의 <code>구조</code>가 정해져 있다면 가능합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="schema-resolver">Schema, Resolver<a class="hash-link" href="#schema-resolver" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4324cd9d-be44-49c7-b604-7c8c8d78c9a4/image.png" class="img_ev3q"></p><p>이 구조를 GraphQL에서는 <code>스키마</code>(schema)라고 합니다.</p><p>스키마는 API가 무엇을 할 수 있는지 기술한 것이기 때문에 GraphQL 클라이언트는 이 스키마를 통해 서비스에 어떻게 요청할지 알 수 있습니다.
스키마는 타입을 가진 필드를 그래프로 나타낸 것이며 이 그래프는 데이터 서비스를 통해 읽고 수정할 수 있는 모든 객체를 보여줍니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3102c4b0-112e-4553-bc69-dd9065e51f88/image.png" class="img_ev3q"></p><p>GraphQL은 프론트엔드 팀과 백엔드 팀이 스키마를 같이 정의하는 것으로 커뮤니케이션 비용을 줄입니다.</p><p>프론트엔드 팀과 백엔드 팀이 회의실에 앉아서 스키마에 대해 토의하고 무엇이 필요한지 정의합니다. 서로 스키마를 공유한다면 더이상의 커뮤니케이션은 필요하지 않습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c09b1615-4b03-40c8-a562-c8106f490305/image.png" class="img_ev3q"></p><p>회의가 끝나면 백엔드 팀은 <code>resolver</code>(이하 리졸버)를 정의하는 것을 통해 같이 정의한 스키마를 충족시킵니다.</p><p>리졸버 함수는 GraphQL의 뒤에서 움직이는 대부분의 처리 로직으로 스키마의 각 필드는 리졸버 함수와 연동되며, 리졸버 함수에는 각 필드가 어떤 값을 가져와야하는지 정의합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ade96a02-182e-44a0-8a53-72071be94d78/image.png" class="img_ev3q"></p><p>정리를 해보면, 프론트엔드팀과 백엔드팀이 먼저 스키마를 정의한 후 백엔드 팀은 그 데이터를 가져오기 위한 리졸버 함수를 정의합니다.</p><p>이후 클라이언트에서 GraphQL 언어로 텍스트 형태로 필요한 데이터를 요청하면 백엔드에서 구현된 GraphQL Runtime이 요청을 해석하여 클라이언트가 원하는 데이터를 내려줍니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="github-api를-이용한-실습">Github API를 이용한 실습<a class="hash-link" href="#github-api를-이용한-실습" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/86984f0f-c4ae-432a-946c-e7194ba79228/image.png" class="img_ev3q"></p><p>Github는 2017년까지 REST API를 사용하다가 GraphQL로 변경했습니다.<br>
<!-- -->이 실습에서는 GraphQL을 사용해서 제가 만든 이슈에 댓글을 달아보는 것을 해보도록 하겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/cc239486-4bf9-49ae-9291-fafa8c56bac7/image.png" class="img_ev3q"></p><p>제가 미리 테스트 이슈를 한개 만들어 놓았고, 이 이슈에 GraphQL을 사용하여 댓글을 달아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9f296806-ca6c-469c-914a-0cd7a6c6b731/image.png" class="img_ev3q"></p><p>아래 링크에 접속한 후 Github 계정으로 로그인 해주세요.</p><p><a href="https://docs.github.com/en/graphql/overview/explorer" target="_blank" rel="noopener noreferrer">https://docs.github.com/en/graphql/overview/explorer</a></p><div class="language-graphql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-graphql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">mutation</span><span class="token plain"> </span><span class="token definition-mutation function" style="color:rgb(80, 250, 123)">AddCommentToIssue</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token property-query">addComment</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token attr-name" style="color:rgb(241, 250, 140)">input</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token attr-name" style="color:rgb(241, 250, 140)">subjectId</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"> </span><span class="token description string" style="color:rgb(255, 121, 198)">&quot;</span><span class="token description string language-markdown" style="color:rgb(255, 121, 198)">I_kwDOH0hUV85Px2eu</span><span class="token description string" style="color:rgb(255, 121, 198)">&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token attr-name" style="color:rgb(241, 250, 140)">body</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;안녕하세요 이현진입니다.&quot;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(98, 114, 164)"># 여러분의 이름으로 바꿔주세요</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token object">commentEdge</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token object">node</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token property">createdAt</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>위 코드를 복사해서 붙여넣은 후 이름을 바꿔주고 실행해주세요.</p><p>이제 실제로 댓글이 잘 작성되었는지 확인하기 위해 아래 링크에 접속해서 확인해보세요.</p><p><a href="https://github.com/hyunjinee/GraphQL/issues/1" target="_blank" rel="noopener noreferrer">https://github.com/hyunjinee/GraphQL/issues/1</a></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/2d67135a-9676-4eb9-a313-f1602bc938a2/image.png" class="img_ev3q"></p><p>위와 같이 댓글이 잘 작성된 것을 볼 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="graphql-in-react">GraphQL in React<a class="hash-link" href="#graphql-in-react" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/90bae2d6-a811-4342-b864-2ac23b84da3a/image.png" class="img_ev3q"></p><p>마지막으로 GraphQL이 React에서 어떤 문제를 해결했는지 알아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d00491c2-9665-4fa7-9a35-9a83a6405ddc/image.png" class="img_ev3q"></p><p>위와같은 블로그 애플리케이션의 구조에서 Posts 컴포넌트와 Profile 컴포넌트 모두 데이터를 불러오는 코드를 갖는 컴포넌트라고 가정해보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/47e74989-bd9b-408e-b9b0-a4bdec1ccba2/image.png" class="img_ev3q"></p><p>추상화 해서 나타내보면 Posts가 상위 컴포넌트이고 Profile이 하위 컴포넌트이며 각각 데이터를 불러오는 코드를 가지고 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/37b7016b-3cc6-483d-b484-a8fff7a36897/image.png" class="img_ev3q"></p><p>Posts와 Profile은 계층 구조를 가지므로 Profile 컴포넌트는 Posts 컴포넌트가 렌더링이 된 이후에야 데이터 fetching을 시작할 수 있습니다. 위 그림을 보면 Posts는 렌더링이 되었지만 Profile은 데이터 fetching을 시작조차 하지 않은 모습을 볼 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f2179c5d-b40d-40d1-9ca2-969b291fb542/image.png" class="img_ev3q"></p><p>이런 현상을 <code>Network Waterfall</code>이라고 합니다.
물론 동시에 요청을 보낼 수 있겠지만 데이터를 가져오는 코드가 컴포넌트와 의존성을 가지므로 동시에 요청을 보내는 것 자체가 불가능합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7c9594a2-3e97-4dd3-a190-243b8b7c448b/image.png" class="img_ev3q"></p><p>물론 위와 같이 데이터를 가져오는 로직을 상위 컴포넌트로 옮기고 <code>props drilling</code>을 하면 해결할 수 있습니다. 하지만 하위 컴포넌트가 여러개라면 상위 컴포넌트가 점점 복잡해질 것입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/85965bf3-62ec-4755-a7d5-3f422369dbbb/image.png" class="img_ev3q"></p><p>무엇이든 복잡한 것을 만들 때는 작은 부분(컴포넌트)으로 나누어 한번에 한 부분만 집중하는 것은 좋은 접근법 입니다. 작은 부분들은 가능하면 서로 의존하지 않게 독립적으로 설계해야 바람직하며, 각 부분별로 테스트 및 재사용이 가능해야합니다.</p><p>GraphQL에서는 각 컴포넌트에 대응하는 데이터를 <code>fragment</code>로 정의할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/1a77b7c0-7812-44a9-a509-243f9224f78c/image.png" class="img_ev3q"></p><p>컴포넌트의 구조를 위와 같이 표현하고 각 컴포넌트가 필요로 하는 데이터 구조를 fragment로 표현합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e8a6de1e-8b9c-4bd3-9345-9aef1cda182e/image.png" class="img_ev3q"></p><p>이제 각 fragment들을 최상위 컴포넌트의 쿼리에 모두 배치시키고 GraphQL의 이점을 살려 단 한번의 쿼리로 모든 데이터를 받아옵니다.</p><p>이렇게 함으로써 애플리케이션 내에서 데이터흐름을 추적하기 쉬워지며 <code>Network Waterfall</code> 현상도 해결할 수 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="마치며">마치며<a class="hash-link" href="#마치며" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5367e6f7-3e23-41a7-9043-4bbff33f2164/image.png" class="img_ev3q"></p><p>GraphQL은 클라이언트에서 서버에 질의를 하기 위한 언어입니다.
GraphQL은 SQL의 경쟁 상대가 아니며, SQL 처럼 데이터베이스에 쿼리를 하기 위해 사용해서는 안됩니다.</p><p>GraphQL는 스키마를 정의하여 클라이언트와 서버가 대화할 수 있게 해줍니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/69bcd0f9-d2a6-4f06-9179-2b198a25234c/image.png" class="img_ev3q"></p><p>만약 백엔드가 다양한 언어로 구성된 여러 서비스로 되어있다면, 리졸버가 여러 서비스와 대화하여 데이터를 가져올 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c8235b23-d1d1-4234-9533-732c0c2d9618/image.png" class="img_ev3q"></p><p><code>GraphQL의 아름다움은 프론트엔드 개발자가 백엔드를 보지 않아도 된다는 것 입니다.</code> 프론트엔드 개발자는 스키마가 정의되면 백엔드 개발자가 어떻게 개발하든 신경쓰지 않아도 됩니다.</p><p>이것이 GraphQL의 의도입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/41ce9f5e-e5eb-4005-aae4-003be49fd109/image.png" class="img_ev3q"></p><p>GraphQL은 API를 위한 쿼리언어이며, 동시에 런타임이기도 합니다. GraphQL은 스키마를 통해 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 리졸버를 통해 원하는 필드에 원하는 데이터를 충족시킬 수 있습니다. 또한, 시간이 지남에 따라 API를 쉽게 진화시킬 수 있고 강력한 개발자 도구를 지원합니다.</p><p>데이터들을 엔드포인트에 대응되는 것이 아닌 서로 그래프처럼 연결되어있다고 생각해보면 어떨까요?</p><p><code>Think in graphs, not endpoints.</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reference">Reference<a class="hash-link" href="#reference" title="Direct link to heading">​</a></h2><ul><li><a href="https://www.howtographql.com/" target="_blank" rel="noopener noreferrer">How to GraphQL</a></li><li>GraphQL in Action. Samer Buna</li><li><a href="https://velog.io/@hyunjine/Data-Flows-in-React" target="_blank" rel="noopener noreferrer">Data Flows in React</a></li><li><a href="https://www.youtube.com/watch?v=HYgKBvLr49c" target="_blank" rel="noopener noreferrer">컴포넌트, 다시 생각하기</a></li><li><a href="https://graphql-kr.github.io" target="_blank" rel="noopener noreferrer">GraphQL Docs</a></li><li><a href="https://www.apollographql.com/docs/" target="_blank" rel="noopener noreferrer">Apollo Docs</a></li><li><a href="https://velog.io/@devstone/GraphQL-%EA%B8%B0%EC%B4%88-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0" target="_blank" rel="noopener noreferrer">GraphQL 기초 톺아보기</a></li><li><a href="https://tech.kakao.com/2019/08/01/graphql-basic/" target="_blank" rel="noopener noreferrer">GraphQL 개념잡기</a></li><li><a href="https://github.com/hyunjinee/GraphQL" target="_blank" rel="noopener noreferrer">발표 Repo</a></li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/graph-ql">GraphQL</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/thinking-in-react"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Thinking in React</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/useState-vs-useRef"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">useState vs useRef</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#intro" class="table-of-contents__link toc-highlight">Intro</a></li><li><a href="#graphql-vs-rest" class="table-of-contents__link toc-highlight">GraphQL vs REST</a></li><li><a href="#schema-resolver" class="table-of-contents__link toc-highlight">Schema, Resolver</a></li><li><a href="#github-api를-이용한-실습" class="table-of-contents__link toc-highlight">Github API를 이용한 실습</a></li><li><a href="#graphql-in-react" class="table-of-contents__link toc-highlight">GraphQL in React</a></li><li><a href="#마치며" class="table-of-contents__link toc-highlight">마치며</a></li><li><a href="#reference" class="table-of-contents__link toc-highlight">Reference</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/team-yaza" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 MOZI, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.9f7dceef.js"></script>
<script src="/assets/js/main.746c5878.js"></script>
</body>
</html>