<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">MOZI | MOZI</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://team-yaza.github.io/blog"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" property="og:title" content="MOZI | MOZI"><meta data-rh="true" name="description" content="MOZI의 개발기록"><meta data-rh="true" property="og:description" content="MOZI의 개발기록"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://team-yaza.github.io/blog"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog" hreflang="en"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="MOZI RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="MOZI Atom Feed"><link rel="stylesheet" href="/assets/css/styles.a7ab553b.css">
<link rel="preload" href="/assets/js/runtime~main.82ffaf65.js" as="script">
<link rel="preload" href="/assets/js/main.16ebe939.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">MOZI</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/Login">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/MOZI">MOZI 최종 발표</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/web-push">Web Push</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seo">SEO 최적화하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/thinking-about-pwa">PWA에 대한 생각</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Sentry로-모니터링-시스템-구축하기">Sentry로 모니터링 시스템 구축하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/dnd">Drag And Drop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mozi-calendar">📅 캘린더 만들기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/thinking-in-react">Thinking in React</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/GraphQL">GraphQL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/service-worker">Service Worker</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/background-sync">Background Sync</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/useState-vs-useRef">useState vs useRef</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/offline-first">서비스 워커로 오프라인 우선 받아들이기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/life-cycle-and-cache-controll">서비스워커의 생명 주기와 캐시 관리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/웹은-어떻게-발전했는가">웹은 어떻게 발전했는가</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-cache-storage-api">CacheStorage API 사용하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-service-worker">서비스워커 사용해보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/What-is-PWA">PWA(Progressive Web App)란 무엇인가?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/rendering-patterns">Rendering Patterns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/프로젝트를-하며-읽은-글">프로젝트를 하며 읽은 글</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/MOZI">MOZI 최종 발표</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-26T00:00:00.000Z" itemprop="datePublished">November 26, 2022</time> · <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/10cf144e-852d-4344-9ecd-0c658b3f0209/image.png" class="img_ev3q"></p><blockquote><p>다크모드를 켜주세요!</p></blockquote><p>안녕하세요 저희는 이현진, 김시온, 유찬희로 이루어진 야자(야간자율학습)팀입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/83d8fdd8-ffed-45e0-b991-e0d2c66fe03d/image.png" class="img_ev3q"></p><p><strong>MOZI</strong>는 할 일 관리 서비스입니다.</p><blockquote><p>메<strong>모지</strong> -&gt; <strong>MOZI</strong></p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3ce5c559-922d-4c89-8168-56a2f61355c5/image.png" class="img_ev3q"></p><p>생산성 분야에서 유명한 책인 David Allen의 <a href="https://ko.wikipedia.org/wiki/Getting_Things_Done" target="_blank" rel="noopener noreferrer">Getting Things Done</a>이라는 책에서 사람들은 무엇이든 할 수는 있지만, 모든 것을 할수는 없다고 말합니다. 모든 것을 하기위해 할 일을 기록하는 것은 필수적입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7b5ed804-4544-4a13-9851-7f6f9d8af534/image.png" class="img_ev3q"></p><p>MOZI에서는 사람들이 <strong>할 일을 관리하는 방식</strong>에 집중했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e0232bc4-142d-4233-9453-f44e1efa6951/image.png" class="img_ev3q"></p><p>기획 단계에서 97명의 참여자를 대상으로 사람들이 할 일을 관리하는 방식을 조사했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d0edf8e8-3d29-42fd-8040-27041f133bf3/image.png" class="img_ev3q"></p><p>먼저 주로 어떤 것을 메모하는지 물어봤습니다.</p><p>대다수의 사람들이 일정 관리를 하기위해 메모를 작성하고 있었고 장보기 목록, 갑자기 떠오른 아이디어, 계정 비밀번호 저장, 맛집 리스트가 뒤를 이었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f75e7ed4-1ae2-4d6d-9dbc-f25b94410cf8/image.png" class="img_ev3q"></p><p>이를 그룹화해서 분류해보면 시간에 관한 메모, 장소에 관한 메모, 시간과 장소모두 관련된 메모로 분류할 수 있었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7bc4a14a-30e7-4d25-849f-da9b0de918ff/image.png" class="img_ev3q"></p><p>저희는 시간과 장소라는 키워드에 주목해봤습니다.
사람들이 원하는 할 일 관리 애플리케이션은 정해진 시간에 할 일을 할 수 있도록 도와줘야합니다. 또한 정해진 장소에서 어떤 할 일을 해야하는지 시각화해서 보여줄 수 있어야합니다.</p><p>정해진 시간에 할 일을 하기위해 <strong>알림</strong> 기능이 필요합니다.
정해진 장소에서 해야하는 일을 확인하려면 <strong>지도</strong>에 할 일을 표시할 수 있어야합니다.</p><p>이 두가지 기능을 핵심으로하여 <strong>MOZI</strong>를 만들었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/adb813c5-bca1-43b6-903f-ed992efb76a2/image.png" class="img_ev3q"></p><p>기존의 서비스에서 시간과 장소에 집중하여 서비스를 만들기로 했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/296514fa-53b0-4540-8bf5-01d7edc94fe8/image.png" class="img_ev3q"></p><p>먼저 저희가 고려한 시간 부분입니다.</p><p>&quot;할 일을 메모해뒀지만 잊어버린 경험이 있으신가요?&quot;라는 설문에 72%의 사람들이 할 일을 메모해뒀지만 까먹은 경험이 있다고 답변하였고 이를 해결하기 위해 각각의 할 일에 대한 알림 기능을 만들었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b5b2144c-9a6d-4218-ad75-2b2136967d61/image.png" class="img_ev3q"></p><p>할 일에 대해서 <strong>알림 시간</strong>과 <strong>DeadLine</strong>을 설정하여 알림이 와야하는 시간과 할 일을 끝내야하는 날짜를 설정하여 관리할 수 있도록 구현했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a9951a74-b422-4600-9cab-5fcd03067c6c/image.png" class="img_ev3q"></p><p>설정한 시간을 바탕으로 캘린더에 시각화해서 보여주고 그 시간이 되면 정해진 내용으로 알림이 오도록 했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e75fcca7-9136-4146-b998-2b20dfc8547b/image.png" class="img_ev3q"></p><p>다음으로 할 일을 지도에 등록할 때 고려한 부분입니다.
할 일을 지도에서 클릭을 통해 쉽게 등록할 수 있도록 구현했습니다.</p><blockquote><p>또한 알림을 받을 범위를 설정할 수 있도록 해서 원하는 범위 내부에서만 알림을 받을 수 있도록 구현했습니다.</p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/98abf88b-41ea-460e-978d-0c80a08af0ee/image.png" class="img_ev3q"></p><p>지도에서 검색을 할 경우 사용자가 원하는 장소로 쉽게 이동할 수 있고 해당 검색 기록은 저장되어 추후에 그 장소로 빠르게 이동할 수 있도록 했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9845516f-c450-4bbd-9d85-7aff88aa8887/image.png" class="img_ev3q"></p><p>장소와 관련하여 사람들에게 더 좋은 경험을 제공하기 위해 현재 위치를 기반으로 장소를 추천해주는 기능을 추가했습니다. 추천되는 장소는 현재 위치에서 가까운 유동인구가 많은 유명한 장소입니다.
사용자는 여행이나 맛집 탐방을 진행할때 해당 기능을 사용하여 유명한 장소를 쉽게 찾아 할 일을 등록할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5a32e81b-74b4-4dc7-a472-ca99085977b6/image.png" class="img_ev3q"></p><p>다음으로 각각의 할 일에 대하여 알림을 받고 싶은 조건을 설정할 수 있도록 했습니다. 시간 알림이나 장소 알림 중 원하는 알림만 받을 수 있으며 시간과 장소 모두 만족하는 조건에 대한 알림을 설정할 수도 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/bd2d30bf-2961-4bf8-b35b-f375776d6efb/image.png" class="img_ev3q"></p><p>MOZI와 같은 할 일 관리 애플리케이션은 시간과 장소에 관계없이 접근가능해야합니다.
예를 들어 밖에서 핸드폰을 하고 있는 중에도 접근가능해야하고, 업무중에 데스크탑에서도 접근할 수 있어야합니다. 심지어는 비행기와 같이 네트워크가 정상적으로 작동하지 않는 상황에서도 접근할 수 있어야합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f0bafccd-6d2e-4752-b37d-762ba624099f/image.png" class="img_ev3q"></p><p>따라서 저희는 MOZI를 어디서든지 접근할 수 있게 만들기 위해 노력했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e63afb86-2a56-467e-ad69-ea0cdab99712/image.png" class="img_ev3q"></p><p>어떠한 상황에서도 애플리케이션을 항상 사용 가능한 상태로 만들기 위해 두가지 상황을 고려했습니다.</p><p>첫째로 <strong>어떤 기기에서도 접근 가능</strong>해야한다.
둘째로 <strong>오프라인 상황에서도 사용</strong>할 수 있어야한다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3a43dc37-171e-4b9a-9e97-d40450c79105/image.png" class="img_ev3q"></p><p>다양한 기기를 지원하려면 안드로이드와 iOS, 즉 네이티브 애플리케이션을 따로 개발해야하며, 웹도 만들어야합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/0bdc0586-0631-4e7d-a7db-b9aba663cfa1/image.png" class="img_ev3q"></p><p>모든 플랫폼에 맞는 애플리케이션을 개발할 수는 없기에 코드를 한번 작성하고 모든 플랫폼을 지원할 수 있는 전략을 채택했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/87669aae-4634-4615-9d84-3ee9ab0f673f/image.png" class="img_ev3q"></p><p>바로 PWA를 활용하는 것 입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/0a006fdd-f640-4644-b0ee-03f0391be7b7/image.png" class="img_ev3q"></p><p>웹과 네이티브 앱을 각각 개발하는 대신에 웹의 장점을 극대화한 PWA를 활용하였습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/fd8a4afe-f0eb-4422-8ce1-700fe11ccd1e/image.png" class="img_ev3q"></p><p>PWA는 웹에서 네이티브 앱의 경험을 느낄 수 있도록 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a856389c-d60e-4fbd-ac0f-b1f8260d27f7/image.png" class="img_ev3q"></p><p>웹에서 설치가능하도록 할 수 있어서 앱스토어를 거치지 않고 핸드폰이나 데스트탑에 바로 설치할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/eba5dad4-0545-4166-ba48-f7fa4eee9314/image.png" class="img_ev3q"></p><p>다음으로 고려한 사항은 오프라인 지원입니다.
PWA도 웹이기 때문에 웹의 한계에 종속될 수 밖에 없습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/19723038-0d84-4285-b7fb-130e82da1a58/image.png" class="img_ev3q"></p><p>웹의 한계는 다음과 같습니다. 웹 브라우저에서 서버가 연결되어있어야만 동작할 수 있다는 것입니다.
데이터를 수정하려면 서버에 요청을 해야합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b2099c99-b636-480b-b670-4abeed15a7b6/image.png" class="img_ev3q"></p><p>네트워크의 연결이 끊어진다면 아무것도 할 수 없습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f00b8af3-9ddc-4a1a-9eef-7459934a6fee/image.png" class="img_ev3q"></p><p>이 네트워크라는 한계에 종속되지 않게 하기 위하여 브라우저에 존재하는 데이터베이스인 IndexedDB를 데이터 통신의 기점으로 사용했습니다. 브라우저에서 유저의 모든 상호작용이 IndexedDB에 저장이되고 네트워크 연결이 되어있으면 서버에 바로 동기화 시킵니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e7b881bb-934a-47fc-9653-cc5c5bb19940/image.png" class="img_ev3q"></p><p>네트워크 연결이 끊어졌을 경우에는 네트워크 연결이 다시 이루어졌을 때 브라우저의 Sync Manager가 네트워크 연결을 감지하고 사용자가 오프라인에서 했던 작업들을 서버에 동기화 시킵니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a29681b1-4b73-4915-a0cb-e0f53225a04c/image.png" class="img_ev3q"></p><p>이를 백그라운드 동기화라고 합니다. 백그라운드 동기화를 통해 기존 웹의 한계를 넘을 수 있습니다.
사용자는 네트워크 연결과 관계없이 웹과 상호작용할 수 있습니다.
또한 오프라인에서 했던 작업들이 온라인에 잘 동기화되었는가 신경쓸 필요가 없습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/afb78464-0b47-4371-ae46-4bb10aebb314/image.png" class="img_ev3q"></p><p>이렇게 저희가 겪었던 두가지 문제를 모두 해결했습니다.
여러 플랫폼을 지원해야하는 문제를 PWA를 사용하여 코드를 한번 작성하는 것으로 해결했습니다.
오프라인에서도 작동해야하는 문제를 백그라운드 동기화 기능을 사용하여 해결했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/48f98c98-3a51-4b09-9c39-6b2350dca022/image.png" class="img_ev3q"></p><p>할 일 관리 서비스는 정말 다양하고 많습니다.
MOZI에서는 브라우저의 장점을 최대한 살려 백그라운드 동기화를 통한 오프라인 기능과 알림 기능을 구현했습니다.</p><p>할 일관리를 <strong>시간과 장소에 특정해 접근</strong>했다는점,<br>
<!-- -->애플리케이션을 <strong>어디서든 쉽게 사용할 수 있다</strong>는점이 저희가 진행한 프로젝트의 <strong>가치</strong>라고 생각합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/712e1167-5a35-4ac9-918b-d1d324da2291/image.png" class="img_ev3q"></p><p>기존 David Allen의 인용문을 확장하면, 사람들은 무엇이든 할 수는 있지만 모든 것을 어디에서나, 언제나 할 수는 없습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/78c7e862-5c4f-4d68-896e-04a62e0515b7/image.png" class="img_ev3q"></p><p>감사합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/98564be1-db78-4974-9298-aa9abbf6a629/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/50b6d5ee-bd02-4849-a748-f290abb7ace6/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9379bae3-c57f-41d7-a0d8-a00eb09a44f7/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7f90e2ae-4a3e-4655-8e80-720fac4b24ca/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b127b730-4ef5-436d-8b0a-4f29be063f48/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/cbc59ac9-817a-4360-a6b8-2d903e3c6dab/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6a65e697-70ce-4615-9b4d-289619861b66/image.png" class="img_ev3q"></p><ul><li><a href="https://github.com/team-yaza/mozi-client" target="_blank" rel="noopener noreferrer">MOZI Client</a></li><li><a href="https://github.com/team-yaza/mozi-server" target="_blank" rel="noopener noreferrer">MOZI Server</a></li><li><a href="https://mozi.vercel.app/blog" target="_blank" rel="noopener noreferrer">MOZI 기술 블로그</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/web-push">Web Push</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-09T00:00:00.000Z" itemprop="datePublished">November 9, 2022</time> · <!-- -->2 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Push API는 웹 애플리케이션이 현재 로딩이 되어 있지 않더라도 서버로부터 메시지를 받을 수 있도록 하는 기능이다. 이는 개발자들이 비동기적으로 사용자에게 새로운 내용을 시기적절하게 전달할 수 있도록 만들어줍니다.</p><p>Web Push의 가장 큰 문제점은 사파리 브라우저에서 지원하지 않는 API가 여럿 있다는 것인데, WWDC22의 Meet Web Push for Safari 세션에서도 웹 푸쉬에 관한 내용이 언급되었습니다.</p><blockquote><p>Web Push is supported in Mac Safari beginning with macOS Ventura. And Web Push will be coming to iOS and iPadOS next year.</p></blockquote><p>애플리케이션이 push 메시지를 받기 위해서, service worker를 활성화합니다.</p><p>PushSubscription에 애플리케이션이 보내야하는 push 메시지를 담고,(엔드 포인트와 암호화키가 필요) service worker는 ServiceWorkerGlobalScope.onpush()라는 이벤트 핸들러로부터 전달되는 push 메시지를 처리하기 시작합니다.</p><p>각 요청은 capability URL:(당신이 애플리케이션)을 특정하여 엔드포인트를 구성하기 때문에 URL은 보안에 신경을 써야하며, 그렇지 않을 경우 다른 애플리케이션이 당신의 애플리케이션에 push 메시지를 보낼 가능성도 있다.</p><p>push 메시지를 전달하기 위해 service worker를 활성화하는건, 리소스 사용이 늘어나는 결과를 가져오기 때문에, 특히 배터리 사용에 영향을 미칩니다. 한편 push 메시지 처리를 위해 브라우저 간 다른 스키마를 가지기 때문에, 표준화된 메커니즘이 없습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="reference">Reference<a class="hash-link" href="#reference" title="Direct link to heading">​</a></h2><ul><li><a href="https://geundung.dev/114" target="_blank" rel="noopener noreferrer">https://geundung.dev/114</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/web-push">WebPush</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/seo">SEO 최적화하기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-05T00:00:00.000Z" itemprop="datePublished">November 5, 2022</time> · <!-- -->2 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="seo란">SEO란?<a class="hash-link" href="#seo란" title="Direct link to heading">​</a></h2><p>SEO란 Search Engine Optimization의 약자로 웹에 올리는 컨텐츠가 구글, 네이버, 다음과같은 검색엔진으로부터 제대로 인식이 될 수 있도록 최적화하는 작업이다. 최적화하는 방법에는 양질의 콘텐츠를 제공하거나, 접근성이나 성능적으로 뛰어난 웹을 개발하는 방법 등이 있지만 가장 기본적인 방법으로는 해당 페이지에 적합한 메타 태그를 삽입해서 크롤러가 웹을 잘 분석해서 인덱싱 하는데 도움을 주는 방법이 있다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/seo">SEO</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about SEO 최적화하기" href="/blog/seo"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/thinking-about-pwa">PWA에 대한 생각</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-10-21T00:00:00.000Z" itemprop="datePublished">October 21, 2022</time> · <!-- -->12 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/197401733-0a32f902-ac76-4da5-b86f-52064d931706.png" class="img_ev3q"></p><p>이번 글에서 다뤄볼 주제는 <code>PWA</code>입니다.</p><p><code>PWA</code>라는 용어는 <code>Progressive Web App</code>의 약자입니다. 이 용어는 이제 많이 퍼져서 많은 사람들이 사용하고 있습니다. 하지만 <code>PWA</code>라는 용어를 쓰는 사람마다 사용하는 기능이 무엇인지에 따라 그 의미가 종종 바뀌기도 합니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/pwa">PWA</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about PWA에 대한 생각" href="/blog/thinking-about-pwa"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/Sentry로-모니터링-시스템-구축하기">Sentry로 모니터링 시스템 구축하기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-10-12T00:00:00.000Z" itemprop="datePublished">October 12, 2022</time> · <!-- -->6 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="프론트엔드-모니터링이란">프론트엔드 모니터링이란<a class="hash-link" href="#프론트엔드-모니터링이란" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://velog.velcdn.com/images/surim014/post/5c70e282-7ecc-4476-b502-1499e1319388/image.webp" class="img_ev3q"></p><p>프론트엔드 모니터링은 웹 사이트 또는 앱의 성능을 추적하는데 사용되는 일련의 프로세스 및 도구입니다. 프론트엔드 모니터링은 주로 사용자가 최종적으로 보는 부분에 중점을 둡니다. 여기에는 다음과 같은 문제가 포함됩니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/sentry">Sentry</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Sentry로 모니터링 시스템 구축하기" href="/blog/Sentry로-모니터링-시스템-구축하기"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/dnd">Drag And Drop</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-10-08T00:00:00.000Z" itemprop="datePublished">October 8, 2022</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>MOZI에서는 할 일을 드래그 앤 드롭을 통해 수정할 수 있어야한다.(예를 들어 할 일 복원) 어떻게 보면 스토리에서 우선순위는 아니였기에 뒤로 미루다가 <a href="https://velog.io/@bepyan/Drag-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%BD%80%EA%B0%9C%EA%B8%B0" target="_blank" rel="noopener noreferrer">벨로그에서 좋은 글</a>을 발견하고 글에 나와있는 프로젝트를 그대로 구현해보면서 배우기로 했다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/react">React</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/dnd">DND</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Drag And Drop" href="/blog/dnd"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/mozi-calendar">📅 캘린더 만들기</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-10-04T00:00:00.000Z" itemprop="datePublished">October 4, 2022</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>MOZI에는 <code>Upcoming</code>이라는 탭이 존재합니다. 이 탭에서는 다가오는 할 일을 볼 수 있고 할 일을 등록할 수 있습니다.</p><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/193635704-98c24679-e5b4-44df-8a35-6f7726ff9122.png" alt="3_Upcoming" class="img_ev3q"></p><p>이 글은 위 화면과 같이 달력을 만들어보면서 겪은 경험을 기록한 글입니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/calendar">Calendar</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about 📅 캘린더 만들기" href="/blog/mozi-calendar"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/thinking-in-react">Thinking in React</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-09-29T00:00:00.000Z" itemprop="datePublished">September 29, 2022</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><img loading="lazy" width="774" alt="스크린샷 2022-09-29 오전 12 11 04" src="https://user-images.githubusercontent.com/63354527/193643629-5f283f85-4f37-4336-a7d1-69a2d72c0fd5.png" class="img_ev3q"><p><code>Thinking in React(React로 생각하기)</code>라는 주제로 발표를 진행하겠습니다. React로 생각한다는 표현이 조금 추상적일 수 있는데, 이 발표에는 React를 다룰 때 갖고 있어야하는 생각들을 담았습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/react">React</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Thinking in React" href="/blog/thinking-in-react"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/GraphQL">GraphQL</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-08-31T00:00:00.000Z" itemprop="datePublished">August 31, 2022</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e254c4ee-c148-4722-8fa9-a98de1baca87/image.png" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="intro">Intro<a class="hash-link" href="#intro" title="Direct link to heading">​</a></h2><blockquote><p>소프트웨어 마에스트로 컨퍼런스 발표(8.31) 내용을 요약한 글 입니다.</p></blockquote><p>안녕하세요. 소프트웨어 마에스트로 연수생 이현진입니다.</p><p>이번 발표에서는 GraphQL의 컨셉, REST API와의 차이, 실제 활용 실습과 더 나아가 React에서 GraphQL이 해결할 수 있는 문제에 대해서 이야기해보도록 하겠습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/graph-ql">GraphQL</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about GraphQL" href="/blog/GraphQL"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/service-worker">Service Worker</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-08-21T00:00:00.000Z" itemprop="datePublished">August 21, 2022</time> · <!-- -->13 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>서비스 워커는 브라우저가 백그라운드에서 실행하는 스크립트로, 웹 페이지와는 별개로 작동하며 웹 페이지 또는 사용자의 인터랙션이 필요하지 않은 기능만 제공하고 있다.
서비스 워커의 수명주기는 웹 페이지와는 완전히 별개이다. 웹 서비스와 브라우저 및 네트워크 사이에서 프록시 서버 역할을 하며, 오프라인에서도 서비스를 사용할 수 있도록 한다.</p><p>웹 페이지와 별개로 존재하기 때문에 다음과 같은 제약이 있다.</p><ol><li>서비스 워커는 요청하지 않는 이상, 없는 것이나 다름이 없다.</li><li>웹 페이지 life cycle을 따르지 않는다. 서비스 워커는 웹 페이지가 닫히더라도 자동으로 비활성화되지 않는다.</li><li>웹 페이지와 별개로 존자해므로 DOM이나 window 요소에 접근할 수 없다.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="캐시와-상호작용">캐시와 상호작용<a class="hash-link" href="#캐시와-상호작용" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/183283272-80e7c99f-1454-42b3-8328-e5f66b31f2dd.png" alt="image" class="img_ev3q"></p><p><code>fetch</code> 이벤트의 중간자 역할로 사용할 수 있다. 이 경우 서비스 워커는 HTTP를 통해 정보를 요청하는 대신 가지고 있는 캐시에서 자료를 전달한다. 캐시가 삭제되지 않는 한 브라우저는 인터넷 연결 없이도 정보를 보여줄 수 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="푸쉬-알림">푸쉬 알림<a class="hash-link" href="#푸쉬-알림" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/183283322-fa0ebaa3-a4f1-43d7-a9ed-c05809b08969.png" alt="image" class="img_ev3q"></p><p>브라우저 창이 닫힌 상태에서도 동작하므로, 푸시 알림을 구현할 수 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="백그라운드-동기화">백그라운드 동기화<a class="hash-link" href="#백그라운드-동기화" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/183283351-6d23a274-9257-41d6-944e-f424b4224991.png" alt="image" class="img_ev3q"></p><p>채팅 메시지 또는 사진 업로드 등의 작업 도중 컴퓨터가 오프라인 상태가 되는 경우 온라인 상태가 되었을 때 해당 작업을 마저 완료할 수 있다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="fetch">Fetch<a class="hash-link" href="#fetch" title="Direct link to heading">​</a></h2><p>fetch란 web resource에 접근하기 위해 행해지는 모든 <code>request action</code>을 의미한다.
service worker는 fetch를 통해 발생하는 모든 http request를 중간에서 가로챌 수 있다. (proxy)
예를 들어 실 서버로 보내지는 request를 중간에서 가로채어 서버로 보내지 말고 대신 cache 된 데이터를 제공하는 등의 처리를 하는 것이 가능하다.</p><p>http request가 있을 때마다 fetch이벤트가 발생하는데 service worker는 fetch event listener를 등록하여 이벤트를 감지하고 있다가 fetch이벤트가 발생할 때 listener에서 request를 intercept하는 방식이다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="메시지를-통한-서비스-워커와-페이지간의-커뮤니케이션">메시지를 통한 서비스 워커와 페이지간의 커뮤니케이션<a class="hash-link" href="#메시지를-통한-서비스-워커와-페이지간의-커뮤니케이션" title="Direct link to heading">​</a></h2><ul><li>윈도우에서 해당 윈도우를 제어하는 서비스 워커로 메시지 보내기</li><li>서비스 워커에서 범위 내의 모든 윈도우로 메시지 보내기</li><li>서비스 워커에서 특정 윈도우로 메시지 보내기</li><li>윈도우간 메시지 보내기 (서비스 워커를 통해)</li></ul><p>페이지에서 서비스워커를 가져오려면 다음과 같이한다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token dom variable" style="color:rgb(189, 147, 249);font-style:italic">navigator</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">serviceWorker</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">controller</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>그 후에는 메시지 자체를 첫번째 인수로 받는 서비스 워커의 <code>postMessage()</code> 메서드를 활용한다.이 메시지는 무엇이든 될 수 있다.</p><p>메시지가 게시되고 나면 서비스 워커는 message 이벤트를 수신하여 해당 메시지를 받을 수 있다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">self</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">addEventListener</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;message&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">data</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>위 예제는 메시지를 받아서 콘솔에 출력한다. 메시지에 포함된 콘텐츠는 이벤트 리스너에 전달된 이벤트 객체의 데이터 속성에서 찾을 수 있다.
메시지 데이터 자체를 포함하는 것 이외에도 이벤트 객체는 여러 유용한 속성을 가지고 있다. 가장 유용한 속성중 일부는 source 속성에 있다.</p><p>source 속성에는 메시지를 보낸 윈도우 정보가 들어있다. 이 정보를 활용해서 무엇을 할지 그리고 응답을 어디로 보낼지 판단할 수 있다.
다음 코드는 메시지의 source 속성을 사용하는 간단한 예제 코드이다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">self</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">addEventListener</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;message&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;Message received:&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">data</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;From a window with the id:&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">source</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">id</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;which is currently pointing at:&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">source</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">url</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;and is&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">source</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">focused</span><span class="token plain"> </span><span class="token operator">?</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;focused&quot;</span><span class="token plain"> </span><span class="token operator">:</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;not focused&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;and&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">source</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">visibilityState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>페이지에서 서비스워커로 해당 페이지를 캐시하라고 요청을 보낸다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token dom variable" style="color:rgb(189, 147, 249);font-style:italic">navigator</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">serviceWorker</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">controller</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">postMessage</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;cache-current-page&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>사용자가 해당 페이지에 방문하면 서비스 워커에 메시지를 보냅니다. 서비스 워커는 이 메시지를 수신하고, 어느 페이지를 캐싱할지 결정하기 위해 이벤트 source 속성의 값을 사용할 수 있다.</p><p>서비스 워커에서 페이지로 메시지를 보내는 것은 페이지에서 서비스 워커로 메시지를 게시하는 것과 비슷하다. 유일한 차이점은 postMessage()를 호출하는 객체이다. 지금까지 서비스 워커에서 postMessage()를 호출했다면 이번에는 서비스 워커 클라이언트에서 호출한다.</p><p>서비스 워커내에서 서비스 워커의 글로벌 객체인 clients 객체를 사용해 현재 서비스 워커 범주안에 열려 있는 모든 윈도우(Window Clients)를 가져올 수 있다. clients 객체는 matchAll 메서드를 가지고 있다. 이 메서드는 서비스워커 범주 내에 열려 있는 모든 윈도우를 가져오는데 사용된다. matchAll() 메서드는 0개 혹은 그 이상의 WindowClient 객체를 담는 배열로 리졸브되는 프로미스를 반환한다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">self</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">matchAll</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">then</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">forEach</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">url</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">includes</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;/my-account&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">postMessage</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;Hi client: &quot;</span><span class="token plain"> </span><span class="token operator">+</span><span class="token plain"> client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">id</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>이 코드는 현재 서비스 워커가 제어하는 모든 클라이언트를 가져와 하나씩 돌며 페이지를 표시하고 있는 윈도우로 메시지를 보낸다.
이 메시지를 윈도우에서 받는 코드는 아래와 같다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token dom variable" style="color:rgb(189, 147, 249);font-style:italic">navigator</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">serviceWorker</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">addEventListener</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;message&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token console class-name">console</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">data</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>서비스 워커가 설치되고 필요한 모든 리소스 캐싱이 끝나면 앱 사용자에게 온라인이든 오프라인이든 상관없이 앱을 사용할 수 있다고 알려야한다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">self</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">addEventListener</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;install&#x27;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  event</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">waitUntil</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    caches</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">open</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token constant" style="color:rgb(189, 147, 249)">CACHE_NAME</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">then</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">cache</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> cache</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">addAll</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token constant" style="color:rgb(189, 147, 249)">CACHED_URLS</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">then</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> self</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">matchAll</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token literal-property property">includeUncontrolled</span><span class="token operator">:</span><span class="token plain"> </span><span class="token boolean">true</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">then</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      clients</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">forEach</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        client</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">postMessage</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;caching-complete&#x27;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>위 코드에서 clients.matchAll()를 호출할 때 옵션 객체를 전달하여 제어되지 않는 클라이언트도 결과에 포함되도록 요청한다.</p><p>사용자가 페이지에 처음 방문하면 서비스 워커가 설치되고 활성화된다. 하지만 페이지는 여전히 서비스 워커에의해 제어되지 않는다.
만일 self.clients.matchAll()에 제어되지 않는 윈도우를 포함하지 않도록 알려주지 않았다면 메시지는 목적지에 도달하지 못한다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="lifecycle">LifeCycle<a class="hash-link" href="#lifecycle" title="Direct link to heading">​</a></h2><p>서비스 워커의 라이프사이클은 복잡하다.<br>
<!-- -->서비스 워커가 무엇을 하려는지, 그리고 어떤 그 라이프사이클이 어떤 이점이 있는지 모른다면, 서비스워커와 싸우고 있는 것처럼 느껴질 수 있다. 하지만 작동 방식을 알고 나면 웹과 네이티브
패턴의 장점을 혼합하여 사용자에게 원활하고 눈에 거슬리지 않는 업데이트를 제공할 수 있다.</p><p>서비스 워커 라이프 사이클의 목적은 다음과 같다.</p><ul><li>Make offline-first possible.</li><li>새 서비스 워커가 현재 서비스 워커를 방해하지 않고 스스로 준비할 수 있도록 허용한다.</li><li>범위 내 페이지가 전체적으로 동일한 서비스 워커에 의해 제어되는지(또는 서비스워커가 없는지) 확인한다.</li><li>한 번에 하나의 사이트 버전만 실행되도록 한다.</li></ul><p>마지막은 매우 중요하다. 서비스 워커가 없으면 사용자는 사이트에 하나의 탭을 로드한 다음
나중에 다른 탭을 열 수 있다. 이렇게 되면 사이트의 두 가지 버전이 동시에 실행될 수 있다.
가끔은 괜찮을 수도 있지만, 스토리지를 다루는 경우 공유 스토리지 관리 방식에 대해 서로 다른
의견을 가진 두 개의 탭이 쉽게 생길 수 있다. 이로 인해 오류가 발생하거나 최악의 경우
데이터가 손실될 수 있다.</p><p>라이프 사이클의 기본에 대해서 알아보자.</p><ul><li><code>install</code> 이벤트는 서비스 워커가 처음 받는 이벤트이며 한 번만 발생된다.</li><li><code>installEvent.waitUntil()</code>에 전달된 프로미스는 설치의 기간과 성공 또는 실패를 알린다.</li><li>서비스 워커는 성공적으로 설치를 완료하고 <code>active</code>가 될 때까지 가져오기 및 푸시 같은 이벤트를 수신하지 않는다.</li><li>기본적으로 페이지 요청 자체가 서비스 워커를 거치지 않는 한 페이지의 fetch는 서비스 워커를
거치지 않는다. 따라서 서비스 워커의 효과를 확인하려면 페이지를 새로고침 해줘야한다.</li><li><code>clients.claim()</code>은 기본값을 재정의하고 제어되지 않은 페이지를 제어할 수 있다.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="install">Install<a class="hash-link" href="#install" title="Direct link to heading">​</a></h3><p>서비스 워커가 받는 첫 번째 이벤트는 <code>install</code>입니다. 이 이벤트는 워커가 실행되는 즉시
트리거되며 서비스 워커당 한 번만 호출됩니다. 서비스 워커 스크립트를 변경하면 브라우저는 이를
다른 서비스 워커로 간주하고 다른 설치 이벤트를 받는다.</p><p>설치 이벤트는 클라이언트를 제어하기 전에 필요한 모든 것을 캐시할 수 있는 기회이다.
<code>event.waitUntil()</code>에 전달한 프로미스는 설치가 완료된 시점과 성공 여부를 브라우저에게
알려준다. 프로미스가 거부되면 설치에 실패했다는 신호가 되고 브라우저는 서비스 워커를 버린다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="activate">Activate<a class="hash-link" href="#activate" title="Direct link to heading">​</a></h3><p>서비스 워커가 클라이언트를 제어하고 <code>push</code> 및 <code>sync</code>와 같은 기능적 이벤트를 처리할 준비가 되면 활성화 이벤트를 받게 된다. 하지만 그렇다고 해서 <code>.register()</code>를 호출한 페이지가 제어되는 것은 아니다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="clients-claim">clients claim<a class="hash-link" href="#clients-claim" title="Direct link to heading">​</a></h3><p>서비스 워커가 활성화되면 서비스 워커 내에서 <code>clients.claim()</code>을 호출하여 제어되지 않는
클라이언트를 제어할 수 있다. 서비스 워커를 사용하여 페이지를 네트워크를 통해 로드할 때와 다르게 로드하는 경우 <code>clients.claim()</code> 없이 로드되는 일부 클라이언트를 서비스 워커가
제어하게 되므로 문제가 될 수 있다.(타이밍의 문제)</p><blockquote><p>많은 사람들이 <code>clients.claim()</code>을 상용구처럼 사용하는 것을 보지만, 저는 거의 사용하지 않습니다. 처음 로드할 때만 중요하며, 점진적인 개선으로 인해 페이지가 서비스 워커 없이도 원활하게 작동하는 경우가 대부분이다.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="updating-the-service-worker">Updating the service worker<a class="hash-link" href="#updating-the-service-worker" title="Direct link to heading">​</a></h2><p>다음 중 하나라도 발생하면 업데이트가 트리거된다.</p><ul><li>범위 내의 페이지로 이동하는 경우</li><li>푸시 및 동기화와 같은 기능적 이벤트는 지난 24시간 이내에 업데이트 확인이 없는 경우이다.</li><li>서비스 워커 URL이 변경된 경우에만 .register()를 호출한다. 그러나 워커 URL을 변경하지 않아야 한다.</li><li>Chrome 68 이상을 포함한 대부분의 브라우저는 등록된 서비스 워커 스크립트의 업데이트를
확인할 때 캐싱 헤더를 무시하도록 기본 설정되어 있다.importScripts()를 통해 서비스
워커 내부에 로드된 리소스를 가져올 떄는 여전히 캐싱 헤더를 존중한다. 서비스 워커를 등록할 때
<code>updateViaCache</code> 옵션을 설정하여 이 기본 동작을 재정의할 수 있다.</li><li>서비스 워커가 브라우저에 이미 있는 것과 바이트 단위로 다르면 업데이트된 것으로 간주된다.</li><li>업데이트된 서비스 워커는 기존 워커와 함께 시작되며 자체 설치 이벤트를 받는다.</li><li>새 워커에 확인되지 않은 상태 코드가 있거나, 구문 분석에 실패하거나, 실행 중에 오류가 발생하거나, 설치 중에
거부되는 경우 새 워커는 버려지지만 현재 워커는 활성 상태로 유지된다.</li><li>설치에 성공하면 업데이트된 워커는 기존 워커가 클라이언트를 0개 제어할 때까지 기다린다.</li><li>self.skipWaiting()은 대기를 방지하여 서비스 워커가 설치가 완료되는 즉시 활성화되도록 한다.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="install-1">Install<a class="hash-link" href="#install-1" title="Direct link to heading">​</a></h3><p>캐시 이름을 static-v1에서 static-v2로 변경했습니다. 즉, 기존 서비스 워커가 여전히 사용 중인
현재 캐시의 내용을 덮어쓰지 않고 새 캐시를 설정할 수 있다.</p><p>이 패턴은 네이티브 앱이 실행 파일과 함께 번들로 제공하는 에셋과 유사하게 버전별 캐시를 생성한다. 아바타처럼 버전에 특정되지 않은 캐시가 있을 수도 있다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="waiting">Waiting<a class="hash-link" href="#waiting" title="Direct link to heading">​</a></h3><p>성공적으로 설치되면 업데이트된 서비스 워커는 기존 서비스 워커가 더 이상 클라이언트를
제어하지 않을 때까지 활성화를 지연한다. 이 상태를 &quot;대기 중&quot;이라고 하며, 브라우저에서
한 번에 하나의 서비스 워커 버전만 실행되도록 하는 방법이다.</p><p>데모 탭이 하나만 열려 있더라도 페이지를 새로 고치는 것만으로는 새 버전이 적용될 수 없다.
이는 브라우저 탐색이 작동하는 방식 때문이다. 탐색할 때 응답 헤더가 수신될 때까지 현재
페이지가 사라지지 않으며, 응답에 <code>Content-Disposition</code> 헤더가 있는 경우에도 현재 페이지가 유지될 수 있다. 이러한 중첩으로 인해 현재 현재 서비스 워커는 새로 고침 중에 항상 클라이언트를 제어해야한다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="activate-1">Activate<a class="hash-link" href="#activate-1" title="Direct link to heading">​</a></h3><p>이전 서비스 워커가 사라지고 새 서비스 워커가 클라이언트를 제어할 수 있게 되면 이 기능이
실행된다. 이때는 데이터베이스 마이그레이션, 캐시 지우기 등 이전 작업자가 사용 중 일 때는
할 수 없었던 작업을 수행하기에 이상적인 시기이다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="참고">참고<a class="hash-link" href="#참고" title="Direct link to heading">​</a></h2><ul><li><a href="https://web.dev/service-worker-lifecycle/#scope_and_control" target="_blank" rel="noopener noreferrer">The service worker lifecycle</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/pwa">PWA</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/2"><div class="pagination-nav__label">Older Entries</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/Login">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/team-yaza" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 MOZI, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.82ffaf65.js"></script>
<script src="/assets/js/main.16ebe939.js"></script>
</body>
</html>