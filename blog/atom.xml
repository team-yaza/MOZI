<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://team-yaza.github.io/blog</id>
    <title>MOZI Blog</title>
    <updated>2022-09-29T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://team-yaza.github.io/blog"/>
    <subtitle>MOZI Blog</subtitle>
    <icon>https://team-yaza.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Thinking in React]]></title>
        <id>thinking-in-react</id>
        <link href="https://team-yaza.github.io/blog/thinking-in-react"/>
        <updated>2022-09-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Thinking in React(React로 생각하기)라는 주제로 발표를 진행하겠습니다. React로 생각한다는 표현이 조금 추상적일 수 있는데, 이 발표에는 React를 다룰 때 갖고 있어야하는 생각들을 담았습니다.]]></summary>
        <content type="html"><![CDATA[<img loading="lazy" width="774" alt="스크린샷 2022-09-29 오전 12 11 04" src="https://user-images.githubusercontent.com/63354527/193643629-5f283f85-4f37-4336-a7d1-69a2d72c0fd5.png" class="img_ev3q"><p><code>Thinking in React(React로 생각하기)</code>라는 주제로 발표를 진행하겠습니다. React로 생각한다는 표현이 조금 추상적일 수 있는데, 이 발표에는 React를 다룰 때 갖고 있어야하는 생각들을 담았습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c7b40d7b-9225-422c-8b96-92979595cdcb/image.png" class="img_ev3q"></p><p>먼저 <code>DOM</code>에 대한 이야기부터 시작해보겠습니다. <code>DOM</code>은 <code>Document Object Model</code>의 약자로, 브라우저가 <code>HTML</code>을 파싱하여 객체 형태로 만든 것을 말합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9743851e-3bfe-4af9-82ea-276cb0eadb77/image.png" class="img_ev3q"></p><p>위와 같은 <code>HTML</code>구조를 갖는 웹사이트가 있다고 가정해보겠습니다.
<code>HTML</code>은 문자열입니다.문자열은 다루기 어렵습니다.(파싱, 합치기등의 작업)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/cfbcd4c4-4d6f-492a-bdd9-162ea47ffb9c/image.png" class="img_ev3q"></p><p>브라우저는 이 다루기 어려운 문자열을 훨씬 다루기 쉬운 객체 형태로 바꿔주고, 이 객체를 <code>DOM</code>이라 합니다. 개발자는 JavaScript를 이용해 <code>DOM</code>을 조작하여 웹 애플리케이션을 개발합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/99b1ec81-37e1-48fd-8c66-c469f45d708d/image.png" class="img_ev3q"></p><p>하지만 JavaScript로 직접 <code>DOM</code>을 조작하는 것은 여러가지 단점이 따라옵니다.</p><ol><li>JavaScript로 <code>DOM</code>을 조작할 때 HTML의 구조를 파악하기 어렵습니다.(<code>DOM</code>을 직접 생성, 수정 삭제할 때 구조를 파악하기 어렵습니다.)</li><li>표준을 따르는 브라우저도 많지만, 그 안에서도 다른 동작을 가지고 있을 수 있습니다.</li><li><a href="https://im-developer.tistory.com/110" target="_blank" rel="noopener noreferrer">Live Collection과 Static Collection</a></li></ol><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4981b176-bf3a-4c99-b5f0-b94e2c0a85fa/image.png" class="img_ev3q"></p><p><code>Live Collection</code>은 <code>DOM API</code>가 반환한 값이 <code>Live</code>한 상태를 의미합니다. 즉, <code>DOM</code>의 실시간 변경사항에 따라 언제든 값이 바뀔 수 있습니다. 반면에 <code>Static Collection</code>은 <code>DOM</code>의 실시간 변경사항에 따라 값이 바뀌지 않습니다.</p><p><code>DOM API</code>는 반환하는 값이 <code>Live</code> 할 수도 있고, <code>Static</code> 할 수도 있기 때문에 <code>"일관성이 없다"</code>라고 표현합니다.</p><p><code>DOM API</code>가 일관성이 없고 사용하기 불편하다면 어떻게 해야할까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/0541ef55-68e9-4f91-a3cc-9983f3d017bd/image.png" class="img_ev3q"></p><p>가장 간단한 답으로는 <code>DOM API</code>을 사용하지 않는 방법이 있습니다. <code>DOM API</code>를 직접 사용하지 않고 중간에 매개체를 두어서 <code>DOM</code>을 조작할 수 있습니다.</p><p>이 매개체가 <strong>React</strong>입니다.</p><p>React는 <code>DOM</code>조작과 같이 어려운 일은 자신이 하고, 개발자에게는 훨씬 편리한 API를 제공해줍니다.</p><p>마치 <code>HTML</code>이라는 문자열을 직접 다루기 어렵기 때문에 <code>DOM</code>이라는 객체를 만든 것 처럼, <code>DOM</code>을 직접 다루기 어렵기 때문에 <code>React</code>를 만든 것이라고 할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7a256c65-927d-4f3b-ab0f-aa1d077ccf7b/image.png" class="img_ev3q"></p><p>React는 웹 애플리케이션의 UI를 재사용 가능한 컴포넌트들을 모아서 구성합니다. 각 컴포넌트에는 <code>데이터 모델</code>이 존재합니다. 애플리케이션의 UI와 상호작용하려면 UI에 내재하는 <code>데이터 모델</code>을 바꿈으로써 상호작용할 수 있습니다.</p><p>이 <code>데이터 모델</code>을 React에서는 <code>State(상태)</code>라고 합니다. <code>상태</code>란 주어진 시간에 대해 시스템을 나타내는 것으로 언제든지 변경될 수 있고 <code>상태</code>가 업데이트되면 React 컴포넌트는 <code>렌더링</code>됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3e57afa8-1ec5-4832-b940-a4fe323e8386/image.png" class="img_ev3q"></p><p><code>렌더링</code>이란 React가 컴포넌트에게 현재 <code>Props</code>와 <code>State</code>에 기반하여 UI에 어떻게 보여지고 싶은지 알려달라고 요청하는 과정입니다. <code>렌더링</code>은 간단히 말해서 함수 컴포넌트를 호출하는 것이라고 할 수 있으며, 함수에서 반환하는 <code>JSX</code>는 시간에 따른 UI의 스냅샷과 같습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3d0db11a-900f-445d-878a-b63fc08153e0/image.png" class="img_ev3q"></p><p>컴포넌트가 위와 같은 트리 구조를 갖고 있다고 해보겠습니다. 빨간색 컴포넌트는 상태가 업데이트된 컴포넌트입니다. 상태가 업데이트되면 컴포넌트는 업데이트가 필요하다는 표시를 합니다.(빨간색 React로고)</p><p>React는 상태 업데이트를 감지하면 렌더링을 <code>큐(queue)</code>에 넣습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/fd9bbf85-7061-4a29-8bfc-41dbe1c6173b/image.png" class="img_ev3q"></p><p>React는 트리의 최상단(<code>A</code>)부터 렌더 패스(<code>Render Pass</code>)를 시작합니다. <code>A</code>에는 업데이트가 필요하다는 마크가 없는 것을 보고 지나칩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/214a6f1d-ba11-4d2b-a367-60edbe14df95/image.png" class="img_ev3q"></p><p>다음은 <code>B</code>를 방문합니다. React는 <code>B</code>에 업데이트가 필요하다는 마크가 있는 것을 보고 렌더링합니다. 여기서 중요한 점은 <strong>React는 기본적으로 부모 컴포넌트가 렌더링되면, 모든 자식 컴포넌트를 재귀적으로 렌더링한다는 점입니다.</strong></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/2979d66f-3274-4061-b076-5fbf15451bc3/image.png" class="img_ev3q"></p><p>이에 따라 <code>C</code>와 <code>D</code>는 업데이트가 필요하다는 마크가 없지만 부모 컴포넌트인 <code>B</code>가 렌더링되었기 때문에 <code>C</code>와 <code>D</code>를 렌더링합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3f6f366c-d41e-440d-b4ee-90576b673eba/image.png" class="img_ev3q"></p><p>다음으로 남은 <code>E</code>를 체크하고 업데이트가 필요하다는 마크가 없으므로 아래로 내려가서 업데이트가 필요하다는 표시가 있는 <code>F</code>를 발견하고 <code>F</code>를 렌더링합니다.</p><p>여기서 컴포넌트 트리 안에 있는 컴포넌트들 중에서는 <code>C</code>, <code>D</code>와 같이 직전과 똑같은 렌더링 결과물을 반환하는 컴포넌트가 존재합니다. 따라서 같은 결과물을 반환하는 컴포넌트는 <code>DOM</code>에 반영할 필요가 없습니다. 하지만 렌더링의 결과물이 같다는 것을 어떻게 알 수 있을까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4b8fd2dc-aa6b-402b-9ec1-8233b371b3e7/image.png" class="img_ev3q"></p><p>React는 <code>VirtualDOM</code>을 활용합니다. 기존 <code>VirtualDOM</code>과 상태 업데이트 후의 <code>VirtualDOM</code>에서 바뀐 부분만을 계산(<a href="https://ko.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer"><code>diffing</code></a>)하여 실제 바뀐 부분만 <code>DOM</code>에 적용합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ff68b753-2e7f-4946-88fe-5fbc6eacf504/image.png" class="img_ev3q"></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/716cf8c9-fa94-4365-8bf3-a4e97569abd5/image.png" class="img_ev3q"></p><p>이를 React에서 <code>Reconciliation(재조정)</code>이라고 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d1af7085-410b-4263-829b-d1d54d359fdf/image.png" class="img_ev3q"></p><p>이러한 사실을 바탕으로 렌더링을 두 단계로 쪼갤 수 있습니다.</p><ul><li><code>Render phase(렌더 단계)</code>: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 과정이 이루어지는 단계(<code>VirtualDOM 조작 단계</code>)</li><li><code>Commit phase(커밋 단계)</code>: 변경 사항을 실제 DOM에 적용하는 단계</li></ul><p><strong>렌더링과 DOM을 업데이트하는 것은 같은 것이 아니며</strong> 컴포넌트는 가시적인 변화가 없어도 렌더링될 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/dc409c72-6550-41fb-84cb-a27a62efed20/image.png" class="img_ev3q"></p><p>렌더링은 기본적으로 <code>상태</code> 업데이트에 의해 발생됩니다. 따라서 React 애플리케이션은 <code>상태 관리</code>를 어떻게 하느냐에 따라 애플리케이션의 미래가 결정됩니다. 불필요하거나 중복된 상태는 버그의 일반적인 원인이 될 수 있습니다.</p><p>즉, 적절한 <code>상태</code>를 적절한 <code>컴포넌트</code>에 배치시켜야합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/04c56eaf-5e05-4622-a401-91473b5ee8ea/image.png" class="img_ev3q"></p><p><code>Props(properties)</code>는 컴포넌트간에 값을 전달할 때 사용합니다.(<code>데이터 전달</code>)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/47988e1a-c5fd-4217-ba98-f9f3a6cfd1dc/image.png" class="img_ev3q"></p><p>예를 들어 하위 컴포넌트 두개가 같은 상태(<code>현진</code>)를 갖는데 두 상태가 항상 함께 변경되기를 원할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/8c8360d9-efe5-4f2c-90d1-e489572d00fe/image.png" class="img_ev3q"></p><p>같이 변경되어야하는 두 상태는 <code>중복 상태</code>이므로 둘 다에서 상태를 제거하고 가장 가까운 공통 부모로 상태를 이동시킨후에 props를 통해 전달합니다. 이를 <code>상태 끌어올리기(Lifting State Up)</code>이라고 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ba942b5e-13ea-4268-ad4f-fdc2c90cda03/image.png" class="img_ev3q"></p><p>상태를 끌어올린 후에 하위 컴포넌트에게 <code>Props</code>로 전달합니다.</p><p>React에서는 데이터의 흐름이 상위 컴포넌트에서 하위 컴포넌트로 한 방향으로만 흐릅니다.(<code>단방향 데이터 흐름, Unidirectional Data Flow</code>)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/889c0267-f501-4d74-aca6-d53041a07401/image.png" class="img_ev3q"></p><p><code>현진</code>이라는 상태를 <code>이현진</code>으로 바꾸고 싶다고 해봅시다.
하위 컴포넌트에서 상위 컴포넌트의 상태를 변경하고 싶다면 어떻게 해야할까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4db9190f-3d10-4e4d-811f-14b1c84c69fe/image.png" class="img_ev3q"></p><p>Props로 <strong>상태를 업데이트하는 함수를 전달</strong>하여 하위 컴포넌트에서 상태를 업데이트하는 함수를 호출하면됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/2ebd2548-5ab0-4d18-977b-d7f9ff68c42c/image.png" class="img_ev3q"></p><p>이렇게 상태를 업데이트하면 하위 컴포넌트에서 상위 컴포넌트의 상태를 업데이트할 수 있습니다. 이렇게 <code>역방향 데이터 흐름(Inverse Data Flow)</code>을 추가할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/30670c8a-6bd1-4bdc-ab6a-d11ae9580b77/image.png" class="img_ev3q"></p><p>지금까지 상태를 애플리케이션에 분배하고 다뤄봤습니다. 브라우저내에서 모든걸 처리할 수 있다면 클라이언트 상태로도 충분하지만 대다수의 애플리케이션은 서버 상태가 존재합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/2fa20785-2bc2-4470-afbf-fa8d9c9b27fe/image.png" class="img_ev3q"></p><p>서버상태는 다음과 같은 특성을 지닙니다.</p><ul><li>서버 상태는 사용자의 제어를 벗어난 위치에서 원격으로 유지된다.</li><li>비동기 요청을 통해 <code>fetching</code>또는 <code>updating</code>이 가능하다.</li><li>소유권을 공유한다. 즉 사용자 모르게 다른 사용자가 변경할 수 있다.</li><li>시간이 지남에 따라 <code>stale</code>또는 <code>outdated</code>된다.</li></ul><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d70765bd-bbc5-40e0-a243-0368270fef8b/image.png" class="img_ev3q"></p><p>React는 UI 라이브러리이기 때문에 데이터를 <code>fetching</code>하는것에는 관심이 없습니다. 단지 <code>fetching</code>한 데이터를 UI에 반영시키는 것에만 관심이 많습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a578f5c7-998c-4fad-8293-86f0cfe87681/image.png" class="img_ev3q"></p><p>React는 상태에 따라 UI를 어떻게 렌더링할지에 관심이 있기 때문에 서버 상태를 다루려면 여러가지 상태를 정의해야합니다. <code>Loading</code>, <code>Error</code>, <code>Success</code> 상태를 정의하여 각각의 상태별로 매 렌더링마다 UI의 스냅샷을 찍어서 보여줍니다.</p><p>React에서는 상태를 업데이트하는 로직이 복잡해지면 <code>reducer</code>를 사용하듯이, 컴포넌트 내부에 <code>Loading</code>, <code>Error</code>, <code>Success</code>와 같은 상태를 두지 않고 전역 상태 관리자인 <code>Redux</code>를 사용하여 상태를 업데이트하는 로직을 컴포넌트 외부로 빼내서 비동기 요청에 대한 렌더링 로직을 작성했습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/194756c0-9119-473c-8914-5085224a6861/image.png" class="img_ev3q"></p><p>여기서 우리는 의문을 제기해야할 필요가 있습니다. <strong>전역 상태관리 라이브러리인 <code>Redux</code>의 역할이 과연 API 요청에 대한 각각의 상태를 정의해 렌더링 로직을 작성하는 것인가?</strong></p><p>답은 아니라고 생각합니다. 전역 상태관리자의 역할은 전체 애플리케이션에서 정말 전역적으로 관리해야하는 상태(theme, 사이드바 상태등)를 가지고 있어야합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9f898be8-0776-49c0-97b7-415096dd01ed/image.png" class="img_ev3q"></p><p>기존에는 API 요청의 상태(Loading, Error, Success)에 따라 적합한 UI를 보여주기 위해 컴포넌트 외부에 수많은 보일러 플레이트 코드를 작성해야했습니다.</p><p>React Query는 이를 해결합니다. React Query의 역할은 명확합니다.</p><p><code>서버 상태를 관리하기위해 필요했던 보일러플레이트 코드를 제거한다. 그리고 단 몇줄의 코드로 대체한다.</code></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/fd41511a-8c9b-44b0-b1a1-86fb7e8253f1/image.png" class="img_ev3q"></p><p>React Query를 사용하면 여러 상태를 정의해야하는 문제는 해결됩니다. 하지만 컴포넌트가 <code>isLoading</code>과 같은 상태일 때 반환할 UI를 정의해줘야합니다.</p><p><strong>이는 UI의 일관성을 해칩니다.</strong></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/507b8693-1f77-4590-b39d-beb1cd980aa9/image.png" class="img_ev3q"></p><p><code>Suspense</code>는 이를 해결합니다. <code>Suspense</code>의 목표는 서버상태를 읽어오는 것을 React의 props와 state처럼 쉽게 다루는 것입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4bedb6b4-fec8-4ae3-bd72-43e37fb8bcff/image.png" class="img_ev3q"></p><p>이렇게 비동기적으로 데이터를 불러오는 컴포넌트를 <code>Suspense</code>감싸고 <code>fallback</code>으로 보여줄 컴포넌트를 전달합니다. 이렇게하면 기존 UI의 로딩 상태를 <code>명령형(imperative)</code> 방식으로 정의해야했던 것을 React의 패러다임에 맞게 <code>선언적(declarative)</code>인 방식으로 바꿀 수 있습니다.</p><blockquote><p>Suspense는 단순히 로딩 스피너가 아닙니다. React 18에서는 Suspense를 이용한 두개의 SSR(Server Side Rendering)기능이 추가됩니다. <a href="https://www.youtube.com/watch?v=pj5N-Khihgc" target="_blank" rel="noopener noreferrer">HTML Streaming과 Selective Hydration</a></p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9123524d-6968-4431-8002-573d5ca2a599/image.png" class="img_ev3q"></p><p>지금까지 React에 관한 다양한 내용들을 다루었는데 마지막으로 React v18에 대해서 이야기해 보려고 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/2b6b6393-cf14-4034-9d2b-24c5fe5e9752/image.png" class="img_ev3q"></p><p><code>2161일.</code> React팀이 React <code>v18.0.0</code>을 릴리즈하는데 걸린 시간입니다.(React팀이 Async rendering이라는 개념을 소개한 이후 2161일 걸림) 왜 이렇게 오래걸렸을까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/63ea9a6f-83a6-4e17-a0f6-f5cf855a1b58/image.png" class="img_ev3q"></p><p>React팀의 목표는 하나였습니다. <code>성능이 좋은 React를 만들어서 수백만개의 React로 만들어진 웹사이트 성능을 높인다.</code></p><p>가장 큰 문제는 React가 아닌 React를 만든 언어에 있었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d511f619-1bb7-4a23-95bc-d7a2c8b84be8/image.png" class="img_ev3q"></p><p>React는 JavaScript 위에서 만들어졌기 때문에 JavaScript의 제약을 따를 수 밖에 없습니다. 특히 JavaScript가 브라우저 위에서 동작하는 방식을 따릅니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/12f2a4c6-5c7b-40df-99f8-13c6eccbf372/image.png" class="img_ev3q"></p><p><strong>브라우저의 메인 스레드는 싱글 스레드로 <code>한번에 하나</code>의 작업만 처리할 수 있습니다.</strong> HTML을 파싱하거나 JavaScript를 실행하거나 화면에 보이는 내용을 렌더링하는데 사용됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7015347b-cf23-44a3-84a5-b23f9487d380/image.png" class="img_ev3q"></p><p>React를 비롯한 대다수의 UI 라이브러리 작동 방식도 이 한계(브라우저의 메인 스레드)에 종속될 수 밖에 없습니다. React도 화면에 그리기 위한 내부 연산, 즉 렌더링을 시작해서 화면을 완성할 때까지 실행을 멈출수 없습니다. 이를 React 팀에서는 블로킹 렌더링이라고 부릅니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/76b8430b-11ae-47e9-87e4-497d6c4561a7/image.png" class="img_ev3q"></p><p>정확히는 React 18 이전까지는 그랬습니다.
React 18에서는 동시성 기능이 추가되었습니다.(<a href="https://www.youtube.com/watch?v=FZ0cG47msEk&amp;t=1255" target="_blank" rel="noopener noreferrer"><code>Concurrent features</code></a>)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/189b5352-c1d1-42bd-a0a6-fe00dab7488d/image.png" class="img_ev3q"></p><p><a href="https://tv.naver.com/v/23652451" target="_blank" rel="noopener noreferrer">동시성이란 두개 이상의 독립적인 작업을 잘게 나누어 Context Switching을 하며 동시에 실행되는 것처럼 보이도록 프로그램을 구조화하는 방법입니다.</a></p><p>동시성 기능을 활용하면 렌더링을 잘게 쪼개어 상태 업데이트에 우선순위를 두어 좀더 긴급한 상태 업데이트를 먼저 수행할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/83f45f6e-3d17-42db-a20e-9ed53e3952a4/image.png" class="img_ev3q"></p><p>동시성 기능은 마치 고속차선과 일반차선을 두는 것과 같습니다. 고속차선으로는 좀더 긴급한 상태업데이트가 지나갈 수 있도록 하고, 일반차선으로는 좀 덜 긴급한 상태업데이트가 지나갈 수 있도록 개발자가 조절할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4f94ab34-cb25-4ab0-b306-568f86c2c088/image.png" class="img_ev3q"></p><p>이제 마지막으로 발표내용을 정리해보겠습니다.</p><ul><li>React는 DOM 조작의 문제점을 해결하기위해 만들어졌다.</li><li>React는 Reconciliation(재조정) 과정을 통해 DOM을 업데이트한다.</li><li>React의 핵심은 상태 관리이다.</li><li>React에서 Concurrent Feature를 활용해 렌더링 우선순위를 정할 수 있다.</li></ul><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/21f54714-a00d-4729-835f-85a35d386757/image.png" class="img_ev3q"></p><p>React는 UI를 변수에 저장할 수 있으며 값으로 전달할 수 있습니다. 즉 React는 <code>value UI</code>입니다.</p><p><strong>React의 핵심 원칙은 UI는 값이라는 것입니다.</strong></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b57a1ce3-31ac-47f2-ad8c-70c7f1eca431/image.png" class="img_ev3q"></p><p>감사합니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="발표자료">발표자료<a class="hash-link" href="#발표자료" title="Direct link to heading">​</a></h2><p><a href="https://drive.google.com/file/d/1cc_6qva6u9h2LOnC6ABlmYANgco7JK7J/view?usp=sharing" target="_blank" rel="noopener noreferrer">Thinking in React.pdf</a>
<a href="https://drive.google.com/file/d/1m9r1bv8sCh-pILg4p8T_mTPmT2Bux4Ph/view?usp=sharing" target="_blank" rel="noopener noreferrer">Thinking in React.key</a></p>]]></content>
        <author>
            <name>이현진</name>
            <uri>https://github.com/hyunjinee</uri>
        </author>
        <category label="React" term="React"/>
        <category label="MOZI" term="MOZI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[useState vs useRef]]></title>
        <id>useState-vs-useRef</id>
        <link href="https://team-yaza.github.io/blog/useState-vs-useRef"/>
        <updated>2022-07-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[React 프로젝트를 진행하면서 input의 값을 관리할 때 useState로 관리할 것인가, useRef로 관리할 것인가에 대해 팀원과 토론했습니다.]]></summary>
        <content type="html"><![CDATA[<p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5c8cfeb8-5f0f-46aa-8cf2-87f00f89f1d1/image.png" class="img_ev3q"></p><p>React 프로젝트를 진행하면서 input의 값을 관리할 때 <code>useState로 관리할 것인가, useRef로 관리할 것인가</code>에 대해 팀원과 토론했습니다.</p><p>이 글은 그 <a href="https://github.com/team-yaza/mozi-client/issues/78" target="_blank" rel="noopener noreferrer">토론</a>에 기반합니다.</p><p>먼저, useState와 useRef를 간단하게 비교하는 것으로 시작해보겠습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="usestate">useState<a class="hash-link" href="#usestate" title="Direct link to heading">​</a></h2><p>React에서 컴포넌트는 자신의 상태 또는 props가 바뀌면 리렌더링됩니다.
상태를 관리하기 위해 React에서는 <code>useState</code>를 활용합니다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">state</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> setState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">initialState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>useState</code>는 상태 유지 값과 그 값을 갱신하는 함수를 반환합니다. <code>setState</code> 함수는 새 state를 받아 컴포넌트 리렌더링 큐에 등록합니다.</p><p>컴포넌트는 다음 렌더링 시에 <code>useState</code>를 통해 반환받은 첫번째 값은 항상 갱신된 최신 state가 됩니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="useref">useRef<a class="hash-link" href="#useref" title="Direct link to heading">​</a></h2><p>Ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공합니다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:rgb(80, 250, 123)">CustomTextInput</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">props</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token comment" style="color:rgb(98, 114, 164)">// textInput은 ref 어트리뷰트를 통해 전달되기 위해서</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token comment" style="color:rgb(98, 114, 164)">// 이곳에서 정의되어야만 합니다.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> textInput </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useRef</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword null nil" style="color:rgb(189, 147, 249);font-style:italic">null</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">handleClick</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    textInput</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">current</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token method function property-access" style="color:rgb(80, 250, 123)">focus</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token operator">&lt;</span><span class="token plain">input type</span><span class="token operator">=</span><span class="token string" style="color:rgb(255, 121, 198)">"text"</span><span class="token plain"> ref</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain">textInput</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token operator">&lt;</span><span class="token plain">button onClick</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain">handleClick</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token operator">&gt;</span><span class="token plain">click me</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">button</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>React 공식 문서에 의하면 ref의 바람직한 사용 사례는 다음과 같습니다.</p><ul><li>포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때</li><li>애니메이션을 직접적으로 실행시킬 때</li><li>서드 파티 DOM 라이브러리를 React와 같이 사용할 때</li></ul><p>결국 React에서 ref는 DOM을 조작하기 위해 사용됩니다.
하지만 ref를 다른 용도로 사용할 수도 있습니다. 아래와 예시를 보겠습니다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> refContainer </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useRef</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">initialValue</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>useRef</code>는 <code>.current</code> 프로퍼티로 전달된 인자(<code>initialValue</code>)로 초기화된 변경 가능한 ref 객체를 반환합니다.</p><p><code>useRef</code>는 순수 자바스크립트 객체를 생성합니다.
또한 <code>useRef</code>로 만든 객체를 수정하는 것은 컴포넌트의 렌더링과 무관합니다.<br>
<!-- -->다시 말하면, <code>.current</code> 프로퍼티를 변형하는 것이 리렌더링을 발생시키지 않습니다.</p><p>본질적으로 <code>useRef</code>는 <code>.current</code> 프로퍼티에 변경 가능한 값을 담고 있는 <code>상자</code>와 같습니다.
<code>useRef</code>는 상자와 같으므로 <code>useState</code>처럼 컴포넌트 내의 변수 값을 조회, 수정하는 방법으로도 사용할 수 있습니다.</p><p>위 두 사례에 의하면, <code>useRef</code>는 일반적으로 특정 DOM을 지정하여 해당 돔의 속성값을 파악하거나 속성값을 변화시키는 용도로 사용할 수도 있고, 순수 자바스크립트 객체를 반환하기 때문에 값을 저장하는 <code>상자</code>로 사용할 수도 있습니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="usestate-vs-useref">useState vs useRef<a class="hash-link" href="#usestate-vs-useref" title="Direct link to heading">​</a></h2><p><code>useState</code>와 <code>useRef</code>의 사용을 비교해보면 렌더링에서 차이점을 보입니다.</p><p>먼저 useState를 사용해서 input을 만들어 테스트를 해보겠습니다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:rgb(80, 250, 123)">Input</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">value</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> setValue</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useState</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">""</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain">input value</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain">value</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"> onChange</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token parameter">e</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">setValue</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">e</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">target</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token property-access">value</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword module" style="color:rgb(189, 147, 249);font-style:italic">export</span><span class="token plain"> </span><span class="token keyword module" style="color:rgb(189, 147, 249);font-style:italic">default</span><span class="token plain"> </span><span class="token maybe-class-name">Input</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/1203cdac-bdb3-4c52-98c5-88113745ab54/image.gif" class="img_ev3q"></p><p>당연하게도 상태가 바뀔 때마다 리렌더링되는 모습을 볼 수 있습니다.</p><p>이제 <code>useRef</code>를 사용해서 input 컴포넌트를 테스트 해보겠습니다.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:rgb(80, 250, 123)">Input</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> inputRef </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">useRef</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token keyword null nil" style="color:rgb(189, 147, 249);font-style:italic">null</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  </span><span class="token keyword control-flow" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> </span><span class="token operator">&lt;</span><span class="token plain">input ref</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain">inputRef</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword module" style="color:rgb(189, 147, 249);font-style:italic">export</span><span class="token plain"> </span><span class="token keyword module" style="color:rgb(189, 147, 249);font-style:italic">default</span><span class="token plain"> </span><span class="token maybe-class-name">Input</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/50749d8d-8a16-4c84-9840-2873da6b8073/image.gif" class="img_ev3q"></p><p>애초에 상태로 관리하지 않으므로 리렌더링이 일어나지 않습니다.</p><p>여기서 고민했던 점은 <code>input 값을 변경할 때 렌더링이 필요한가</code>에 대한 부분이었습니다.</p><p>팀원과 제 생각이 같았던 부분은 <code>input을 입력하는 과정에서 렌더링이 이렇게 많이 일어나야하나?</code>라는 생각이었습니다.</p><p>반면 팀원과 제 생각이 달랐던 부분은 다음과 같습니다.</p><ul><li>이현진: 'input의 입력값 또한 어플리케이션의 상태이기 때문에 <code>useState</code>로 관리해야한다'</li><li>팀원: 'input 입력값은 상태가 아니기 때문에 <code>useRef</code>로 리렌더링을 막아야한다.'</li></ul><p>결국 input 값을 관리할 때 <code>useState vs useRef</code>라는 질문은 React에서 <code>input값이 상태인가</code>라는 질문으로 귀결됩니다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="생각">생각<a class="hash-link" href="#생각" title="Direct link to heading">​</a></h2><p>제 생각은 아래와 같습니다.</p><p><code>상태란 주어진 시간에 대해 시스템을 나타내는 것으로 언제든지 변경될 수 있는 것</code>입니다.
사용자가 입력하는 값 또한 어플리케이션의 상태라고 할 수 있고, 시간의 흐름에 따라 변하는 input의 값은 <code>useState</code>로 관리해야합니다.</p><p>input을 state로 관리할 때 발생하는 리렌더링에 대한 부분에서는 과연 그 input을 리렌더링하는게 고비용 연산인가라는 의문을 제기하고 싶습니다. input을 타이핑할 때 발생하는 렌더링은 고비용 연산이 아니라고 생각합니다.</p><p>반면 <code>useRef</code>로 만들어진 ref객체는 DOM에 접근할 때나, 매 렌더링시에 만들어줘야하는 고비용 객체나 값을 저장할 때 사용하는 것이 옳다고 생각합니다.</p><p>결론은 <code>input에서 발생하는 사용자의 상호작용 또한 어플리케이션의 상태이므로 상태를 상태답게 관리하기 위해 useState를 사용해야한다.</code> 입니다.</p><p><strong>여러분은 어떻게 생각하시나요?</strong></p><blockquote><p>22.08.03 추가</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="controlleduncontrolled-components">Controlled/Uncontrolled Components<a class="hash-link" href="#controlleduncontrolled-components" title="Direct link to heading">​</a></h2><p>이 글에서 했던 고민이 공식문서에 나와있었습니다.</p><p>우리의 고민은 이 컴포넌트가 <code>Controlled Component</code>인가 <code>Uncontrolled Component</code>인가에 대한 고민이었습니다.</p><p>HTMLElement중에는 상태를 가지고 있는 것들이 있습니다.</p><ul><li>input</li><li>select</li><li>textarea</li></ul><p>이 HTMLElement들의 상태를 누가 관리하느냐에 따라 <code>Controlled Component</code>와 <code>Uncontrolled Component</code>로 나뉩니다.</p><p>엘리먼트를 가지고 있는 컴포넌트가 관리한다면, <code>Controlled Component</code></p><p>엘리먼트의 상태를 관리하지 않고 엘리먼트의 참조만 컴포넌트가 소유한다면, <code>Uncontrolled Component</code>입니다.</p><p>즉, 쉽게 말하면 <code>useState</code>에 의해 상태로 관리하고 있는 컴포넌트를 <code>제어 컴포넌트</code>라고 하고, React가 상태로 추적하고 있지 않은 컴포넌트를 <code>비제어 컴포넌트</code>라고 합니다. <code>비제어 컴포넌트</code>같은 경우 ref를 활용해 실제 DOM에 접근합니다. <code>비제어 컴포넌트</code>는 DOM자체에서 데이터가 다뤄집니다.</p><p>아래는 공식문서에서 인용한 문장입니다.</p><blockquote><p>In a controlled component, form data is handled by a React component.
The alternative is uncontrolled components, where form data is handled by the DOM itself.</p></blockquote><blockquote><p>(번역)
<strong>대부분 경우에 폼을 구현하는데 제어 컴포넌트를 사용하는 것이 좋습니다.</strong>
제어 컴포넌트에서 폼 데이터는 React 컴포넌트에서 다루어집니다.
대안인 비제어 컴포넌트는 DOM 자체에서 폼 데이터가 다루어집니다.</p></blockquote><p>form의 input 상태같은 경우 React가 추적해서 그 값으로 어떤 행동을 할 여지가 있습니다. 예를들어서 로그인 유효성 검사 로직이 state가 변함에 따라 실행되어야하면 <code>제어 컴포넌트</code>를 활용할 수 있습니다.</p><p>반면에, <code>비제어 컴포넌트</code>같은 경우는 실제 DOM을 참조해야하는 경우에 필요합니다. 가장 흔한 경우로 input에 focus를 하는 상황을 예로 들 수 있습니다.</p><p>따라서, <strong>실제 DOM에 접근해야하는 상황이 아니라면 React 컴포넌트가 input의 상태를 관리해야 합니다.(<code>제어 컴포넌트</code>)</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="더-읽을거리">더 읽을거리<a class="hash-link" href="#더-읽을거리" title="Direct link to heading">​</a></h2><ul><li><a href="https://en.reactjs.org/docs/uncontrolled-components.html" target="_blank" rel="noopener noreferrer">비제어 컴포넌트</a></li></ul>]]></content>
        <author>
            <name>이현진</name>
            <uri>https://github.com/hyunjinee</uri>
        </author>
        <category label="React" term="React"/>
        <category label="MOZI" term="MOZI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[웹은 어떻게 발전했는가]]></title>
        <id>웹은-어떻게-발전했는가</id>
        <link href="https://team-yaza.github.io/blog/웹은-어떻게-발전했는가"/>
        <updated>2022-07-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[소프트웨어 마에스트로 컨퍼런스 발표 (22.05.10)]]></summary>
        <content type="html"><![CDATA[<p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9e3546c1-e4fb-4f2c-8962-6e091b55048b/image.png" class="img_ev3q"></p><blockquote><p>소프트웨어 마에스트로 컨퍼런스 발표 (22.05.10)
소프트웨어 마에스트로 세미나(야간자율학습 팀) 발표 (22.07.03)
CNU SW Academy 발표 (22.07.06)
<a href="https://github.com/hyunjinee/storyofweb" target="_blank" rel="noopener noreferrer">발표 REPO</a></p></blockquote><p>안녕하세요. 프론트엔드 개발자 이현진입니다.
오늘 이야기할 주제는 '웹은 어떻게 발전했는가'입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f451b560-f8b4-4c5b-9198-dd203946eea4/image.png" class="img_ev3q"></p><p>발표는 우선 웹의 역사를 먼저 살펴보고, 그 후에는 브라우저에 관해서 이야기 해보고, 마지막으로 렌더링 프로세스에 대해서 이야기 해보려고 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c7303f7b-52cf-4862-a14d-a026263f1432/image.png" class="img_ev3q"></p><p>인터넷과 웹은 같을까요? 다를까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/1a856237-748d-4467-a16d-c0e534ac846e/image.png" class="img_ev3q"></p><p>다릅니다.
인터넷이 도시이면 웹은 그 도시 위에있는 건물 하나입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ad17e156-1695-4854-b61c-d339647dc250/image.png" class="img_ev3q"></p><p>인터넷이 운영체제라면 웹은 그 위에서 실행되는 프로그램 하나입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6bff2517-5687-40d3-bf01-7ce74efcd92d/image.png" class="img_ev3q"></p><p>인터넷이라는 전체안에 웹이라는 부분이 존재하고 웹과 동급인 여러가지 서비스들이 있고 이 세가지 이외에도 수많은 서비스들이 존재합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/1609430d-13f3-4287-a088-61c91cc00bba/image.png" class="img_ev3q"></p><p>이제 웹이야기를 해보겠습니다. 이분은 웹의 아버지라고 불리는 분입니다. (팀 버너스 리)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4a9dc774-df73-466f-9bee-6b2181fd176e/image.gif" class="img_ev3q"></p><p>팀 버너스 리는 1990년 10월에 세계 최초로 웹페이지를 만드는 편집기를 만듭니다.
바로 다음달인 11월에 세계 최초의 웹 브라우저인 World Wide Web이라는 프로그램을 만듭니다. 이 프로그램은 위와 같이 생겼습니다.<br>
<!-- -->또 다음달인 12월 24일 팀 버너스리는 웹서버라는 프로그램을 만들고, 그 프로그램이 설치되어있는 컴퓨터에 <a href="http://info.cern.ch" target="_blank" rel="noopener noreferrer">info.cern.ch</a>라고 하는 주소를 부여합니다. 접속하면 위와 같이 나옵니다.
웹의 고향에 오신 것을 환영합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3d0572e0-c901-46a2-a89d-ba32f4570a43/image.png" class="img_ev3q"></p><p>이제 현대의 웹으로 잠깐 점프를 하도록 하겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/dcc8ca4a-1af8-4092-9df6-1c78908472f8/image.png" class="img_ev3q"></p><p>오늘날의 웹은 크게 SPA(Single Page Application)과 MPA(Multi Page Application)으로 나뉩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/aad927a2-1937-44fa-b0d4-8469cf67c263/image.gif" class="img_ev3q"></p><p>위 홈페이지는 MPA입니다. 링크를 클릭할 때마다 깜빡거리는 현상을 볼 수 있습니다. MPA는 탭을 이동할 때마다 서버로부터 새로운 html을 받아와서 페이지 전체를 새로 렌더링하는 전통적인 웹 페이지 구성 방식입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/fa89b134-8b0e-4e67-b906-77d008904c87/image.png" class="img_ev3q"></p><p>이런 MPA의 단점 때문에 AJAX가 등장하면서부터는 원하는 부분만 클라이언트에서 동적으로 갈아끼울 수 있고 화면 깜빡임도 없는 SPA의 형태로 점차 바뀌게 되었습니다.</p><p>AJAX란 Asynchronous JavaScript And XML의 약자로 비동기 자바스크립트와 XML을 말합니다. 간단히 말하면, 서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것을 말합니다. JSON, XML등 다양한 포맷을 주고 받을 수 있습니다. AJAX의 강력한 특징은 페이지 전체를 리프레쉬하지 않고도 수행되는 <code>비동기성</code>입니다. 이러한 비동기성을 통해 사용자의 이벤트가 있으면 전체 페이지가 아닌 일부분만을 업데이트 할 수 있게 해줍니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/25f6ba0d-972c-4dd0-88cf-756abd005222/image.png" class="img_ev3q"></p><p>SPA는 하나의 페이지로 구성된 웹 애플리케이션입니다. 오늘날의 SPA는 대부분 React, Vue, Angular를 활용해서 만들어집니다. SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초 한번에 다운도르 합니다. 그 이후 새로운 페이지 요청이 있을 경우, 페이지 갱신에 필요한 데이터만 전달받아 페이지를 갱신합니다. 어떤 링크를 클릭한다해도 그에 관련된 모든 파일을 다운로드 받는게 아니라, 필요한 정보만 받아서 그 정보를 기준으로 업데이트 할 뿐입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/17fc86e7-d431-4dd3-872b-0f370600e761/image.gif" class="img_ev3q"></p><p>위 홈페이지는 미니 프로젝트 때 만들었던 SPA입니다. 링크를 눌러도 화면의 깜빡임 없이 바로바로 반응하는 것을 볼 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/45029a0b-2b4c-43ae-9808-23e9e9f545eb/image.png" class="img_ev3q"></p><p>일반적으로 SPA에서는 렌더링 방식으로 CSR을 MPA에서는 렌더링 방식으로 SSR을 사용합니다.
SPA는 웹 애플리케이션에 필요한 정적 리소스를 처음 한번만 다운로드하고 그 이후 새로운 페이지 요청이 있을 때만 데이터를 전달받아서 클라이언트에서 페이지를 갱신하기 때문에 자연스럽게 CSR을 사용하게 되고, MPA는 새로운 요청이 있을 때마다 서버에서 이미 렌더링된 정적 리소스를 받아오기 때문에 렌더링 방식으로 자연스럽게 SSR을 사용하게 됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b9e45c64-95a9-4eb7-8125-047172fe3d92/image.png" class="img_ev3q"></p><p>CSR에 대해서 좀 더 자세히 알아보겠습니다.
유저가 웹사이트를 방문하면 서버는 빈 뼈대 HTML과 연결된 JS링크를 줍니다. 브라우저는 JS를 다운로드하고 실행합니다. 그리고 JS가 동적으로 DOM을 만들어서 브라우저에 띄워줍니다.</p><p>CSR은 JS가 동적으로 DOM을 만들기 때문에 초기 로딩 속도가 느립니다. 하지만 로딩이후에는 빠르게 동작한다는 장점이 있습니다.</p><p>유저가 컨텐츠를 보는 시간까지를 Time To View 즉, TTV 라고 하고 유저가 컨텐츠와 상호 작용을 할 수 있는 시간을 Time To Interact 즉 , TTI라고 하는데 CSR은 이 둘이 일치한다는 장점이 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c391f9fe-ac90-4c90-8a04-7b335a0925ac/image.png" class="img_ev3q"></p><p>다음으로 SSR에 대해서 자세히 알아보도록 하겠습니다.
우선 웹사이트에 방문하면 서버는 렌더링 준비를 마친 HTML을 줍니다. 브라우저는 HTML을 렌더링하고, JS를 다운로드한 후 연결합니다. 이는 초기 로딩 속도가 매우 빠르다는 장점이 있습니다. 하지만 이 시점에는 사용자가 버튼을 클릭하거나 이동하려고 해도 아무 반응이 없을 수 있습니다. 인터렉션 가능한 페이지처럼 보이지만 실제로는 내용과 스타일이 입혀진 껍데기에 불과하고 JS로직이 모두 연결될 때까지 사용자의 입력에 응답할 수 없기 때문입니다. 그래서 SSR페이지는 TTV와 TTI가 다르다는 특징이 있습니다. 또한 SSR은 SEO(Search Engine Optimization), 즉 검색엔진 최적화에 유리합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e7bb4623-16a4-4c3c-8fe5-4b793387bd43/image.png" class="img_ev3q"></p><p>이제 브라우저에 대해서 이야기를 해보도록 하겠습니다.
브라우저의 주요 기능은 사용자가 요청한 자원을 서버에 요청하고 브라우저에 표시하는 것 입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6bef5b7a-90b3-43dd-b90b-00e92fac1095/image.png" class="img_ev3q"></p><p>브라우저에 대해서 이해하기 위해 브라우저가 어떻게 구성되어있는가 살펴보겠습니다.
우선 유저인터페이스는 주소표시줄이나, 이전/다음버튼, 새로고침 버튼등 유저가 상호작용할 수 있는 부분들을 의미합니다.</p><p>렌더링엔진은 요청한 콘텐츠, 즉 HTML이나 CSS를 파싱하여 화면에 표시하는 역할을 하고, 브라우저 엔진은 유저인터페이스와 렌더링 엔진 사이의 동작을 제어하는 역할을 합니다.
Networking은 HTTP요청과 같은 네트워크 호출에 사용되고,
JavaScript Interpreter는 자바스크립트 코드를 해석하고 실행합니다. 대표적으로 크롬의 V8엔진을 예로 들 수 있습니다.
Display Backend 는 기본적인 위젯을 그리는 역할을 하고, Data Persistance는 Local Storage나 쿠키등 클라이언트 사이드에서 데이터를 저장하는영역을 의미합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a9d6bd11-cfca-4606-a2fb-8054e0671b60/image.png" class="img_ev3q"></p><p>작업관리자나 활성 상태보기를 했을 때 이렇게 크롬의 프로세스가 많이 떠있는 것을 보신적이 있으신가요?
크롬창을 여러개 띄우면 왜 이렇게 많은 프로세스들이 실행되는 것인지 방금 살펴본 브라우저의 구조를 중심으로 알아보도록 하겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/7203878e-d546-4e93-82e8-5fdacaac8ab7/image.png" class="img_ev3q"></p><p>브라우저도 프로그램이기 때문에 실행시키면 프로세스가 생성됩니다.
프로세스는 컴퓨터 프로그램의 인스턴스입니다.
스레드는 프로세스 내부에 있으며 프로세스로 실행되는 프로그램의 일부를 실행합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d9a350bd-31bc-4a0b-95d1-2149135f8e5f/image.png" class="img_ev3q"></p><p>프로세스는 여러 작업을 수행하기 위해 운영체제에 다른 프로세스를 실행하라고 요청할 수 있습니다. 그러면 메모리의 다른 부분에 새 프로세스가 할당됩니다.
두 프로세스가 서로 정보를 공유해야 할 때는 IPC 즉, 프로세스 간 통신를 사용합니다. 많은 애플리케이션이 이러한 방식으로 작동하도록 설계되어 있다. 그래서 작업 프로세스가 응답하지 않을 때 애플리케이션의 다른 부분을 실행하는 프로세스를 중지하지 않고도 응답하지 않는 프로세스를 다시 시작할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/bc058cfe-e5f7-430c-8bda-522cb97de790/image.png" class="img_ev3q"></p><p>브라우저는 프로세스와 스레드를 어떻게 사용할까요?</p><p>프로세스를 한개만들고 여러개의 스레드를 사용할 수도 있고, 프로세스를 여러개 만들고 그안에 스레드를 조금만 만들어 IPC로 통신할 수도 있습니다.
왼쪽그림은 브라우저 프로세스 한개에 스레드가 여러개 있는 브라우저 구조이고, 오른쪽 그림은 프로세스 여러개를 사용하는 브라우저 구조입니다.</p><p>여기에서 주목해야 할 중요한 점은 브라우저마다 이를 다르게 구현할 수 있다는 점 입니다.</p><p>브라우저를 만드는 방법에 대한 표준은 없고, 브라우저마다 접근 방식이 완전히 다를 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/62f95736-13e8-43dd-9d24-ed38f1680114/image.png" class="img_ev3q"></p><p>그렇다면 크롬은 어떨까요?
크롬은 다중 프로세스 아키텍처입니다.
탭마다 프로세스를 할당하는 방법을 process per tab이라고 하고, 사이트마다 프로세스를 할당하는 방법을 process per site 라고 하는데 크롬은 아래 링크에서 이를 설정할 수 있도록 해놨습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e8b43259-42ef-4511-9fae-3c5e7356b61b/image.png" class="img_ev3q"></p><p>브라우저에서 제일 위에 있는 브라우저 프로세스는 어플리케이션의 각 부분을 맡고 있는 프로세스를 조정합니다. 또한 렌더러 프로세스는 여러개 만들어져서 각 탭마다 할당됩니다.</p><p>이제 브라우저의 렌더러 프로세스가 HTML, CSS, JavaScript를 화면에 어떻게 그리는가에 대해서 알아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/84704b0a-22d4-4708-bd9c-06c5fee9a4e4/image.png" class="img_ev3q"></p><p>첫번째로 렌더러 프로세스는 우선 서버로 부터 전송받은 HTML을 파싱해서 DOM Tree를 구축합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/89b50d0e-afc0-4faf-afd9-42491575b489/image.png" class="img_ev3q"></p><p>두번째로는 CSS를 파싱해서 CSS Object Model 트리를 구축합니다.</p><p>CSS는 렌더링을 할 때 반드시 필요한 리소스이기 때문에 render blocking resource 입니다.
렌더링을 막기 때문에 브라우저는 빠르게 CSS를 다운로드하는 것이 좋습니다.
따라서 HTML의 head태그 안에서 정의하여 빠르게 리소스를 받을 수 있도록 해야 합니다. (CSS는 브라우저에 캐시 처리 가능)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c17631c9-9dfc-42df-97fd-6313665d7884/image.png" class="img_ev3q"></p><p>세번째로 DOM트리와 CSSOM트리를 합쳐서 Render Tree를 구성합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/0a34e93b-4e3e-4bb6-abe4-4cbd97445167/image.png" class="img_ev3q"></p><p>다음으로 레이아웃입니다.
기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산하는 과정을 말합니다.
모든 상대적인 측정값은 화면에서 절대적인 픽셀로 변환되서 각 노드들이 어디에 배치되어야 할지 계산합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/21ce463f-4fc4-482d-9d7b-9c21c7a7e8b9/image.png" class="img_ev3q"></p><p>렌더 트리의 각 노드를 화면의 실제 픽셀로 나타내는 과정을 Painting라고 합니다.
Painting 과정 후 브라우저 화면에 UI가 나타나게 됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/cfb6fd93-5a9e-45e3-b320-1587dd51c5a2/image.png" class="img_ev3q"></p><p>마지막으로 정리하고 마치도록 하겠습니다.</p><p>브라우저의 Renderer 프로세스에 의해 실행되는 브라우저가 화면에 HTML, CSS, JavaScript 를 그리는 과정을 Critical Rendering Path, 즉 CRP 라고 합니다.</p><p>첫번째로 HTML을 파싱해서 Document Object Model 트리를 만들고 CSS를 파싱해서 CSS Object Model 트리를 만듭니다.
이 둘을 결합해서 렌더트리를 만들고 이 렌더 트리를 어디다 배치할지 계산하는 과정 Layout 과정을 거치고, 마지막으로 화면에 그리는 Paint과정을 거쳐서 사용자에게 화면을 보여줍니다. (Layout이 다시 진행되는 것을 Reflow, Paint가 다시 진행되는 것을 RePaint라고 합니다.)</p><p>이렇게 웹의 역사 및 브라우저, 그리고 CRP에 대해 알아봤습니다.</p><p>이 발표가 웹을 더 깊이있게 이해하는데 도움이 되었으면 좋겠습니다.</p><p>감사합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/b5581b79-824d-449b-8cb5-11ba6864d416/image.png" class="img_ev3q"></p>]]></content>
        <author>
            <name>이현진</name>
            <uri>https://github.com/hyunjinee</uri>
        </author>
        <category label="WEB" term="WEB"/>
        <category label="MOZI" term="MOZI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rendering Patterns]]></title>
        <id>rendering-patterns</id>
        <link href="https://team-yaza.github.io/blog/rendering-patterns"/>
        <updated>2022-07-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[발표 영상]]></summary>
        <content type="html"><![CDATA[<p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6daef53b-f21a-40d7-9b31-7fee6c586662/image.png" class="img_ev3q"></p><p><a href="https://www.youtube.com/watch?v=baVuNEoMOr0" target="_blank" rel="noopener noreferrer">발표 영상</a></p><p>안녕하세요 소프트웨어 마에스트로 연수생 프론트엔드 개발자 이현진 입니다.
웹 페이지를 그리는 다양한 렌더링 방식 즉 Rendering Pattern들에 대해 이야기 해보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9fb837bd-c81c-44bd-bea3-eebba30d93b5/image.gif" class="img_ev3q"></p><p>렌더링은 브라우저 화면에 웹 페이지를 그리는 것을 말합니다. 먼저 유저가 브라우저를 통해 서버에 요청을 보내고, 서버는 이에 응답으로 HTML, CSS, JavaScript를 보내줍니다. 브라우저는 이를 해석하여 웹 페이지를 그립니다. (렌더링을 수행하는 브라우저의 프로세스를 렌더러 프로세스라고 합니다.)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/1b858f59-55e1-47bb-a220-300e8a092a37/image.png" class="img_ev3q"></p><p>브라우저가 화면에 HTML, CSS, JavaScript를 그리는 과정(절차)를 <code>CRP</code>(Critical Rendering Path)라고 합니다.
이 과정은 우선 DOM Tree와 CSSOM Tree를 만들고, 이 둘을 결합하여 Render Tree를 만듭니다. 다음에는 Render Tree를 배치하는 Layout과정, 화면에 직접 그리는 Paint 과정을 따릅니다.
위 그림에서 DOM Tree 부터 Render Tree를 만들기까지를 <code>Construction</code> 과정, Layout과 Paint를 <code>Operation</code> 과정이라고 합니다.
<img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4b3611a5-bd74-479e-ba94-26cce050f983/image.png" class="img_ev3q"></p><p><code>CRP</code>를 알아야하는 이유는 우리가 작성한 코드가 렌더링에 직접적으로 영향을 미치기 때문입니다.
예를 들어 특정 요소를 안보이게 처리하고 싶을 때 <code>display: none</code>을 사용한다면 Tree들을 만드는 <code>Construction</code> 과정부터 <code>Operation</code>과정까지 다시 진행하기 때문에 렌더링 과정에 있어서 비효율성을 초래합니다. 따라서 <code>opacity</code>나 <code>visibility</code>속성을 사용하는것이 더 효율적입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/0b75cbd1-8ae0-4cea-bb79-c724b1173cd8/image.png" class="img_ev3q"></p><p>이전 예시에서 알 수 있는 사실은 렌더링은 <code>UX</code>(User Experience)와 <code>DX</code>(Developer Experience)에 직접적으로 영향을 미친다는 것 입니다. 개발자가 작성하는 코드에 따라 렌더링의 속도가 달라질 수 있고 개발자는 어플리케이션의 첫 사용자(First User)이기도 하므로 <code>DX</code>에 영향을 미칩니다. 또한 개발자가 채택한 렌더링 패턴은 최초 유저인 개발자에게 영향을 미치고 이는 결국 <code>UX</code>에 영향을 미칩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/47798163-2b27-4fe8-89ec-b7f8b3aacf66/image.png" class="img_ev3q"></p><p>따라서 우리는 올바른 렌더링 방법을 채택하는 것이 중요합니다.
그렇다면 어떤 렌더링 패턴이 올바른 것 일까요? 또, 올바르다는 기준은 무엇일까요?</p><p>올바른 렌더링 패턴이란, 우리의 어플리케이션의 특성에 맞고, <code>UX</code>와 <code>DX</code>를 모두 높여주는 패턴을 말합니다.</p><p>어플리케이션을 만들 때 고려해야 할 요소는 검색엔진 최적화, Web Performance등이 있습니다. 검색엔진 최적화는 SSR(Server Side Rendering) 해결할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/56195331-4fb3-487b-b69d-543fde74dd3c/image.png" class="img_ev3q"></p><p>Web Performance에서 고려할 점은 구글에서 제안하는 웹 사용자 경험에 대한 지표인 Core Web Vitals입니다.</p><ul><li><code>TTFB</code>(Time To First Byte): 웹 페에지 컨텐츠의 첫 byte가 브라우저에 도달하는데 걸리는 시간</li><li><code>FCP</code>(First Contentful Paint): 초기 DOM 컨텐츠를 렌더링하는데 걸리는 시간</li><li><code>LCP</code>(Largest Contentful Paint): 가장 큰 컨텐츠(보통 중요한 컨텐츠일수록 크기가 큼)를 페이지에 렌더링하는데 걸리는 시간</li><li><code>TTI</code>(Time To Interactive): 컨텐츠와 상호작용까지의 시간(CSR에서는 TTV(Time To View)와 TTI가 같고 SSR에서는 TTV와 TTI가 다르다.)</li><li><code>CLS</code>(Cumulative Layout Shift): 누적 레이아웃 이동으로 사용자가 예상치 못한 레이아웃 이동을 경험하는 빈도를 수량화. 시각적 안정성을 측정할 때 중요한 사용자 중심 메트릭</li><li><code>FID</code>(First Input Delay): 사용자가 페이지와 처음 상호 작용할 때(버튼 클릭 등) 부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측적하는 지표.</li></ul><p>이 Core Web Vitals는 '어떤 방식으로 렌더링을 하냐'에 따라 수치가 달라집니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/4466d59c-4613-4a1e-ae74-27148884700a/image.png" class="img_ev3q"></p><p>'어떤 방식으로 렌더링을 하냐'는 어떤 렌더링 패턴으로 페이지를 렌더링 할 것인가로 귀결됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/bf2094d4-5ccf-4277-b4c3-287fdce99041/image.gif" class="img_ev3q"></p><p>Core Web Vitals를 기준으로 렌더링 패턴들의 특징을 알아보겠습니다.</p><p>CSR의 렌더링 과정은 먼저 유저의 요청에 의해 브라우저가 프론트엔드 서버로 HTML을 요청합니다. 서버는 빌드 타임에 미리 생성해 둔 HTML을 응답합니다. 이 HTML에는 로더나 skeleton UI가 들어 있습니다.</p><p>그 후에 head 태그에 정의된 CSS와 같은 렌더링 차단 리소스(다운로드되기 전까지 렌더링을 막음)를 다운 받는데, 보통 이런 리소스는 브라우저에 캐시 처리합니다.</p><p>다음으로 body 태그의 마지막 부분에 위치한 React앱이 들어있는 bundle을 프론트엔드 서버에 요청합니다. bundle을 body태그의 가장 아래에 위치시키는 이유는 자바스크립트는 문서를 파싱하다가 JavaScript를 만나면 파싱을 중지하고 JavaScript 엔진에게 권한을 넘겨서 JS를 실행하기 때문입니다.(Parse Blocking Resource)</p><p>React앱이 실행되면 이제 컨텐츠(데이터)를 받아오기 위해 API 서버로 요청을 보내고 응답을 받아서 유저에게 컨텐츠를 보여줍니다.</p><p>위 내용을 정리하면 유저는 아래와 같은 요청을 기다려야 합니다.</p><ol><li>HTML 파일을 요청해서 응답을 받고</li><li>JavaScript 번들을 요청해서 응답을 받고</li><li>번들을 실행하고</li><li>API 서버로 부터 응답을 받고 데이터를 렌더링</li></ol><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/3a8847a2-867a-4dd1-9c99-a360c040b486/image.png" class="img_ev3q"></p><p>CSR을 Core Web Vitals 관점으로 보겠습니다. 우선 오른쪽 아래에 표시된 파란색 표시는 브라우저에서 일어나는 과정을, 빨간색 표시는 서버에서 일어나는 과정을 뜻합니다. 또한 Network 부분과 Main Thread 부분을 나눴습니다.(Main Thread는 브라우저의 렌더러 프로세스의 Main Thread를 말합니다.)
유저가 HTML을 요청하고 서버가 이에 응답하여 브라우저에 컨텐츠의 첫 byte가 도달하는 순간을 TTFB라고 합니다. 이후에는 HTML을 파싱하고 body태그 맨 아래에 script 태그에 도달하면 bundle.js파일을 서버에서 받아오기 위해 요청을 보냅니다. 이 때 브라우저에서는 Operation과정이 수행되고 bundle을 가져오면 이제 JavaScript를 Evaluation하면서 다시 Operation을 실행합니다. 이 과정을 마치면 HTML에 JavaScript가 연결되어서 유저가 버튼을 클릭하면 연결된 로직이 수행됩니다.(TTI)</p><p>이제 서버로부터 데이터를 받아오기 위해 <code>/api/buildings</code>라는 엔드포인트에 요청을 보내고, 데이터를 받아옵니다. 데이터를 받아오면 브라우저는 바뀐 부분을 다시 그리는데 이 과정을 <code>hydration</code>이라고 합니다.</p><p><code>hydration</code>이 완료되는 시간이 <code>LCP</code>(Largest ContentFul Paint)를 의미합니다. LCP는 보통 페이지에서 중요한 요소를 로드하는데 까지 걸리는 시간인데 CSR에서는 상대적으로 느리다는 것을 알 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/551f4cca-8f6c-4b10-9f56-0a5df7de7ace/image.png" class="img_ev3q"></p><p><code>hydration</code>을 시각적으로 이해하기 위해 데모 페이지를 만들었습니다.</p><p><a href="https://rendering-patterns.vercel.app/" target="_blank" rel="noopener noreferrer">DEMO</a></p><p><code>hydrate</code>은 <code>수분을 공급하다</code>라는 뜻을 가지고 있습니다. 왼쪽 브라우저에는 skeleton UI가 있고 오른쪽 브라우저에는 빌딩 데이터가 채워져 있습니다.
즉<code>hydration</code>이란, API요청을 통해 데이터라는 수분을 페이지에 공급해주는 것 이라고 할 수 있습니다.</p><blockquote><p><strong>hydration</strong>
페이지가 브라우저에 로드되고 자바스크립트 코드가 실행되면서 페이지가 인터렉티브하게 동작하는 상태가 되는 과정</p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5a1e5a80-e922-489e-a21e-6c9dd4035e12/image.png" class="img_ev3q"></p><p>다음으로 SSR(Server Side Rendering)입니다. 유저가 프론트엔스 서버에 HTML 파일을 요청하면 서버는 API 서버에 요청을 보내서 데이터를 받아와 컨텐츠를 채우고 완성된 HTML 파일을 클라이언트에게 보내줍니다.</p><p>기존 React앱이 실행된 후에 보내던 API 요청을 서버에서 미리 보내는 것 입니다. 따라서 유저는 한번의 요청만으로 보고 싶은 컨텐츠를 바로 보게 됩니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6ebea75c-b7ff-4a76-a1b6-c6b3b4ebcd30/image.png" class="img_ev3q"></p><p>SSR을 Core Web Vitals 관점으로 보겠습니다. SSR이 이루어진 후 첫 바이트가 유저에게 도착하고, 유저에게 도착한 HTML은 컨텐츠를 포함하기 때문에 그 HTML을 렌더하는 순간 FCP(First Contentful Paint), LCP(Largest Contentful Paint)가 동시에 발생합니다. 마지막으로 JS를 로딩하면 유저가 인터렉션 가능한 페이지가 되므로 TTI는 마지막에 일어납니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6ccbd3ba-d6b2-4d0f-b6fe-f06b15f97d4f/image.png" class="img_ev3q"></p><p>여러분의 컨텐츠가 빈번하게 바뀐다면 CSR과 SSR을 같이 활용할 수 있는데, SSR을 마친뒤에 <code>hydration</code>과정이 추가됩니다. <code>hydration</code> 과정에는 react-query나 swr같은 data-fetching 라이브러리를 주로 활용합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/80ab2b0b-af09-431a-8155-654b6f2e57da/image.png" class="img_ev3q"></p><p>React에서는 SSR을 구현하기위해 React 프레임워크인 Next.js를 사용합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a1c6b341-29c5-4fe7-8649-535a69ea28e0/image.png" class="img_ev3q"></p><p>Next.js는 기본적으로 모든 페이지를 pre-render(미리 렌더링)합니다.
Client Side JavaScript가 페이지의 HTML을 다 그리는 것이 아니라 미리 각 페이지를 위한 HTML을 생성합니다.</p><p>각각 생성된 HTML 페이지에는 최소한의 자바스크립트가 연결되고 Client Side에서는 이 자바스크립트로 <code>hydration</code>과정이 일어납니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/d186b858-c6d7-474f-9f19-f0a9997c85d7/image.png" class="img_ev3q"></p><p>Next.js의 pre-rendering 형태는 <code>SSG</code>(Static Site Generation)과 <code>SSR</code>(Server Side Rendering)으로 나뉘며 각 페이지별로 다르게 적용할 수 있습니다.</p><p>예를 들어 Page A는 <code>SSG</code>로, Page B는 <code>SSR</code>로, Page C는 <code>CSR + SSR</code>로, Page D는 <code>CSR</code>로 렌더링 할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/10619935-1655-49d1-8c62-7a72a86b5666/image.png" class="img_ev3q"></p><p>Next.js의 pre-rendering 형태중 <code>SSG</code>에 대해서 먼저 알아보겠습니다. <code>SSG</code>는 빌드 타임에 HTML 페이지를 생성합니다.
데이터를 받아오는 API 요청 또한 빌드 타임에만 실행합니다. 따라서 API 서버의 부하가 줄어듭니다. 또한, 만들어진 컨텐츠를 CDN에 캐시함으로써 사용자에게 컨텐츠를 매우 빠르게 전달할 수 있습니다.
단점으로는 빌드 타임에 컨텐츠를 만들기 때문에 변하는 데이터에 취약합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/24ac7cbc-bd1c-4ba8-8552-6dc3ec2b1212/image.png" class="img_ev3q"></p><p><code>SSG</code>에 <code>CSR</code>을 곁들이면 변하지 않는 부분은 변하지 않게 고정하고, 유동적으로 데이터를 fetching 해야하는 부분은 <code>CSR</code>로 처리할 수 있습니다.(<code>hydration</code>) 또한, 두 렌더링 방식을 합쳤기 때문에 장점 또한 합쳐집니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/19d25656-0260-429c-ab6a-a8e6a1c7cae6/image.png" class="img_ev3q"></p><p><code>ISR</code>(Incremental Static ReGeneration)은 <code>SSG</code>에서 <code>revalidation</code> 옵션을 추가한 것 입니다. 빌드 타임에 HTML을 생성하는 것은 동일하나 일정 주기마다 데이터의 최신 여부를 검사해서 업데이트된 데이터로 페이지를 다시 생성합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/290f8f65-d32f-4888-86ec-a795a2e54e83/image.png" class="img_ev3q"></p><p>마찬가지로 <code>CSR</code>을 곁들이면 바뀌긴 하는데 자주 변하지 않는 데이터는 <code>ISR</code>의 렌더링 방법을, 동적으로 계속 바뀌는 데이터들은 <code>CSR</code>로 처리할 수 있습니다. 예를 들면 블로그 글(자주 안바뀜)과 댓글(자주 바뀜)을 이 방식으로 처리할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/96bbbcea-112b-41c2-8e22-00b5e45dc303/image.png" class="img_ev3q"></p><p>마찬가지로 <code>SSG</code> 또한 Core Web Vitals 관점으로 보겠습니다.
<code>SSG</code>로 만들어진 사이트이기 때문에 빌드 타임에 이미 HTML이 완성되어 있습니다. 따라서 서버에서는 마땅히 할 일이 없기 때문에 HTML을 바로 주고 클라이언트는 그 HTML을 바로 렌더링합니다. <code>CSR</code>을 곁들인다면 뒤에 <code>hydration</code> 과정이 추가되겠죠.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5b077a22-99f9-4b18-8b22-492a6bd24fe3/image.png" class="img_ev3q"></p><p>다시 <code>SSR</code>입니다. <code>SSR</code>이야기를 다시 꺼낸 이유는 Next.js<code>SSR</code>의 Page단위 data fetching에 있습니다.</p><p><code>getServerSideProps</code>라는 함수는 API서버로부터 데이터를 가져온 후에 해당 데이터를 사용한 props를 리턴해주면 페이지 컴포넌트는 그 props를 바로 사용할 수 있습니다. 만약 <code>CSR</code>에서 <code>SSR</code>로 마이그레이션 한다고하면 기존 클라이언트 사이드의 data fetching 로직을 <code>getServerSideProps</code>로 옮기면 됩니다. 하지만 여러 컴포넌트에서 여러개의 데이터를 fetching 한다면 처리가 어려워집니다. 또한 props drilling을 하면 관심사의 분리가 되지 않으므로(위 예제에서 A컴포넌트는 data에 관심이 없음) 좋지 않은 해결 방법입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/917df990-ceae-4af1-bd6b-50a05aee1cdd/image.png" class="img_ev3q"></p><p>이를 해결하는 것이 RSC(React Server Component)입니다. RSC는 컴포넌트 개별 단위별로 서버에서 data fetching을 할 수 있으며 서버의 리소스에 자유롭게 접근할 수 있습니다. 또한 서버컴포넌트는 클라이언트로 전송되는 번들에 포함되지 않으며, 클라이언트의 상태를 유지하며 refetch할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/13465e72-b67f-4818-925f-b7173b8fac4f/image.png" class="img_ev3q"></p><p>결국 이런 렌더링 패턴들을 알아야하는 이유는 렌더링 패턴이 UX와 DX에 직접적으로 연관이 있기 때문입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e6d10946-1df5-479a-a21d-129fb125ad8f/image.png" class="img_ev3q"></p><p>우리는 흔히 이런 개발 사이클을 돌곤 합니다. 엄청난 아이디어가 떠오르고, 개발을 한 후 배포를 합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/5c6b6ff7-3f4b-4d72-a544-dcdfa8cbcf32/image.png" class="img_ev3q"></p><p>그렇다면 이 과정에서 렌더링 패턴은 언제 고려되어야 할까요?</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/87c555cc-d884-4f23-8dab-b2e41398e76a/image.png" class="img_ev3q"></p><p>정답은 없습니다. 어디서든지 렌더링 패턴을 고려할 수 있지만, 어플리케이션이 어떤 컨텐츠를 렌더링하냐에 따라 적용할 패턴이 바뀔 것 같습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/18e1c107-c172-44f5-a452-2aa5a7761a3f/image.png" class="img_ev3q"></p><p>저는 특정 패턴이 좋고 나쁘고를 주장하는 것이 아닙니다.
단지 웹을 렌더링하는 방법에는 다양한 렌더링 패턴이 존재하고, 이 패턴들은 모두 trade-off가 있을 뿐 입니다.</p><p>이 발표가 효율적인 렌더링 패턴을 찾는데 도움이 되었으면 좋겠습니다.</p><p>감사합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e90d588d-8b1d-4d50-90f9-1c8ad6a50808/image.png" class="img_ev3q"></p><p><a href="https://github.com/hyunjinee/rendering-patterns" target="_blank" rel="noopener noreferrer">발표 REPO</a></p>]]></content>
        <author>
            <name>이현진</name>
            <uri>https://github.com/hyunjinee</uri>
        </author>
        <category label="React" term="React"/>
        <category label="Next" term="Next"/>
        <category label="MOZI" term="MOZI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MOZI]]></title>
        <id>welcome</id>
        <link href="https://team-yaza.github.io/blog/welcome"/>
        <updated>2022-06-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[안녕하세요. 저희는 소프트웨어 마에스트로 13기 🌴 야간자율학습(야자)팀 입니다.]]></summary>
        <content type="html"><![CDATA[<p>안녕하세요. 저희는 소프트웨어 마에스트로 13기 🌴 <a href="https://github.com/team-yaza" target="_blank" rel="noopener noreferrer">야간자율학습(야자)</a>팀 입니다.<br>
<!-- -->저희는 소프트웨어 마에스트로 본과정인 6월부터 팀으로 구성되어 함께 <code>MOZI</code>라는 서비스를 기획하고 개발했습니다.</p><p><img loading="lazy" alt="Docusaurus Plushie" src="/assets/images/docusaurus-plushie-banner-a60f7593abca1e3eef26a9afa244e4fb.jpeg" width="1500" height="500" class="img_ev3q"></p>]]></content>
        <author>
            <name>이현진</name>
            <uri>https://github.com/hyunjinee</uri>
        </author>
        <author>
            <name>유찬희</name>
            <uri>https://github.com/HanCiHu</uri>
        </author>
        <author>
            <name>김시온</name>
            <uri>https://github.com/sion-k</uri>
        </author>
        <category label="Software Maestro" term="Software Maestro"/>
        <category label="MOZI" term="MOZI"/>
        <category label="CNU" term="CNU"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MDX Blog Post]]></title>
        <id>mdx-blog-post</id>
        <link href="https://team-yaza.github.io/blog/mdx-blog-post"/>
        <updated>2021-08-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Blog posts support Docusaurus Markdown features, such as MDX.]]></summary>
        <content type="html"><![CDATA[<p>Blog posts support <a href="https://docusaurus.io/docs/markdown-features" target="_blank" rel="noopener noreferrer">Docusaurus Markdown features</a>, such as <a href="https://mdxjs.com/" target="_blank" rel="noopener noreferrer">MDX</a>.</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_S0QG"><p>Use the power of React to create interactive blog posts.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token operator">&lt;</span><span class="token plain">button onClick</span><span class="token operator">=</span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">alert</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">'button clicked!'</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token operator">&gt;</span><span class="token maybe-class-name">Click</span><span class="token plain"> me</span><span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">button</span><span class="token operator">&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><button>Click me!</button></div></div>]]></content>
        <author>
            <name>Sébastien Lorber</name>
            <uri>https://sebastienlorber.com</uri>
        </author>
        <category label="docusaurus" term="docusaurus"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Long Blog Post]]></title>
        <id>long-blog-post</id>
        <link href="https://team-yaza.github.io/blog/long-blog-post"/>
        <updated>2019-05-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is the summary of a very long blog post,]]></summary>
        <content type="html"><![CDATA[<p>This is the summary of a very long blog post,</p><p>Use a <code>&lt;!--</code> <code>truncate</code> <code>--&gt;</code> comment to limit blog post size in the list view.</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p>]]></content>
        <author>
            <name>Endilie Yacop Sucipto</name>
            <uri>https://github.com/endiliey</uri>
        </author>
        <category label="hello" term="hello"/>
        <category label="docusaurus" term="docusaurus"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[First Blog Post]]></title>
        <id>first-blog-post</id>
        <link href="https://team-yaza.github.io/blog/first-blog-post"/>
        <updated>2019-05-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet]]></summary>
        <content type="html"><![CDATA[<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet</p>]]></content>
        <author>
            <name>Gao Wei</name>
            <uri>https://github.com/wgao19</uri>
        </author>
        <category label="hola" term="hola"/>
        <category label="docusaurus" term="docusaurus"/>
    </entry>
</feed>