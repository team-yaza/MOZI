<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">PWA에 대한 생각 | MOZI</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://team-yaza.github.io/blog/thinking-about-pwa"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="PWA에 대한 생각 | MOZI"><meta data-rh="true" name="description" content="이번 글에서 다뤄볼 주제는 PWA입니다."><meta data-rh="true" property="og:description" content="이번 글에서 다뤄볼 주제는 PWA입니다."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-10-21T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/hyunjinee"><meta data-rh="true" property="article:tag" content="PWA,MOZI"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://team-yaza.github.io/blog/thinking-about-pwa"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog/thinking-about-pwa" hreflang="en"><link data-rh="true" rel="alternate" href="https://team-yaza.github.io/blog/thinking-about-pwa" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="MOZI RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="MOZI Atom Feed"><link rel="stylesheet" href="/assets/css/styles.b2d9e02d.css">
<link rel="preload" href="/assets/js/runtime~main.1951fb87.js" as="script">
<link rel="preload" href="/assets/js/main.c89cc93c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/mozi.svg" alt="MOZI" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">MOZI</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seo">SEO 최적화하기</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/thinking-about-pwa">PWA에 대한 생각</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/Sentry로-모니터링-시스템-구축하기">Sentry로 모니터링 시스템 구축하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/dnd">Drag And Drop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mozi-calendar">📅 캘린더 만들기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/thinking-in-react">Thinking in React</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/GraphQL">GraphQL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/background-sync">Background Sync</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/useState-vs-useRef">useState vs useRef</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/offline-first">서비스 워커로 오프라인 우선 받아들이기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/life-cycle-and-cache-controll">서비스워커의 생명 주기와 캐시 관리</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/웹은-어떻게-발전했는가">웹은 어떻게 발전했는가</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-cache-storage-api">CacheStorage API 사용하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/use-service-worker">서비스워커 사용해보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/What-is-PWA">PWA(Progressive Web App)란 무엇인가?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/rendering-patterns">Rendering Patterns</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/프로젝트를-하며-읽은-글">프로젝트를 하며 읽은 글</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/welcome">MOZI</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">PWA에 대한 생각</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-10-21T00:00:00.000Z" itemprop="datePublished">October 21, 2022</time> · <!-- -->12 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hyunjinee.png" alt="이현진"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hyunjinee" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">이현진</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p><img loading="lazy" src="https://user-images.githubusercontent.com/63354527/197401733-0a32f902-ac76-4da5-b86f-52064d931706.png" class="img_ev3q"></p><p>이번 글에서 다뤄볼 주제는 <code>PWA</code>입니다.</p><p><code>PWA</code>라는 용어는 <code>Progressive Web App</code>의 약자입니다. 이 용어는 이제 많이 퍼져서 많은 사람들이 사용하고 있습니다. 하지만 <code>PWA</code>라는 용어를 쓰는 사람마다 사용하는 기능이 무엇인지에 따라 그 의미가 종종 바뀌기도 합니다.</p><p>따라서 우리는 먼저 PWA라는 용어를 파헤쳐볼 필요가 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/9b3b64b3-811a-4dda-819f-d37009a99590/image.png" class="img_ev3q"></p><p>먼저 <code>Progressive Web App</code>는 앞으로 다가올 <strong>웹의 가능성의 상징</strong>이라고 표현할 수 있습니다. <code>Progressive</code>은 <code>점진적인, 진보적인</code>이라는 뜻을 가지고 있기 때문에 <code>PWA</code>을 그대로 해석하면 <code>점진적인 웹 앱</code>이고 이는 기본적인 웹에 점진적으로 여러가지 기능을 추가할 수 있음을 의미합니다.</p><blockquote><p><strong>그냥 좋은 비타민을 한껏 섭취한 웹 사이트다.(<a href="http://bkaprt.com/pwa/01-01/" target="_blank" rel="noopener noreferrer">앨릭스 러셀</a>)</strong></p></blockquote><blockquote><p>PWA는 새롭게 자라는 기술에 이름을 붙인 것입니다. 마치 <a href="https://ethanmarcotte.com/" target="_blank" rel="noopener noreferrer">이단 마콧(Ethan Marcotte)</a>이 반응형 웹 디자인에 이름을 붙인 것과 같은 이유이죠. 모두가 열광할 수 있는 무언가를 던져준 것입니다.</p></blockquote><p>정의를 명확하게 하지 않는 것이 PWA에 관심을 끌어모으는데 도움이 될 수 있습니다. <strong>하지만 PWA를 기획하고 개발하려면 PWA가 무엇인지 명확하게 파악해야합니다.</strong></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/bd3f2674-1bb5-4eb9-bcff-99f50b2ce07a/image.png" class="img_ev3q"></p><p>프로그레시브 웹 앱은 웹이 앱과 같은 사용자 경험을 제공할 수 있다는 믿음에 기반합니다. 그리고 이 믿음을 실현하기 위해 2015년에 이르러서는 크롬에 <strong>설치 가능한 웹 앱</strong>이라는 기능을 포함시켰고, 곧 다른 웹 브라우저도 이 기능을 넣기 시작했습니다. 기술이 먼저 나왔지만 이를 가리킬 용어가 없었습니다. 온라인 경험을 더 가치있게 만들어주는 일련의 복잡한 기법들을 간단히 부를 수 있는 방법이 필요했습니다. <strong>그래서 이 웹 앱을 프로그레시브 웹 앱(Progressive Web App)이라고 부릅니다.</strong></p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/c558bbd6-1b28-4e6e-a852-86d799eb7c6b/image.png" class="img_ev3q"></p><p>베리먼과 러셀은 PWA의 특징을 아홉가지로 <a href="http://bkaprt.com/pwa/01-01/" target="_blank" rel="noopener noreferrer">문서화</a>했습니다.</p><p>위 기능이 모두 포함되어야 PWA가 되는 것은 아닙니다. <strong>단지 PWA는 점진적 향상(Progressive Enhancement)전략으로 제작됩니다.</strong> 점진적 향상이란 PWA로 작동하는 최소한의 서비스를 만들고 점차 다른 기능들을 추가하는 개발방법을 말합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a5a8e198-d3a8-4e50-b882-ac6285c12f96/image.png" class="img_ev3q"></p><p>그렇다면 PWA로 작동하는 최소한의 서비스를 만들기위해 최소한으로 갖춰야하는 부분을 기술적 관점에서 알아보겠습니다.</p><p>먼저<code>HTTPS</code>입니다. 프로그레시브 웹 앱은 HTTPS를 이용해 안전하게 서비스되어야 합니다. 프로그레시브 웹 앱의 대부분의 기능은 <code>서비스 워커(Service Worker)</code>를 통해 제공되는데 <code>서비스 워커</code>는 HTTPS에서만 사용할 수 있습니다.</p><p><code>서비스 워커</code>란 웹 브라우저의 네트워크 요청과 자원 관리자를 개발자가 중간에서 직접 제어하도록 해줍니다. 서비스 워커를 이용하면 오프라인에서도 작동하는 웹 페이지를 제작할 수 있습니다.</p><p>마지막으로 <code>Web App Manifest</code>입니다. 프로그레시브 웹 앱이 검색될 수 있도록 해주는 간단한 파일입니다. 앱의 이름, 시작 URL, 아이콘등 웹사이트를 앱으로 인식할 수 있게 해주는 여러가지 정보를 입력합니다.</p><p>위 세가지 조건을 충족하면 PWA라고 할 수 있습니다. 다른 기능은 PWA의 정의처럼 점진적으로 붙여나갈 수 있습니다.</p><p>서비스 워커와 Web App Manifest에 대해서 더 자세히 알아보겠습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/a6cf0e40-c177-472f-9999-78b0d54325f8/image.png" class="img_ev3q"></p><blockquote><p><strong>서비스 워커는 자바스크립트 파일입니다.</strong></p></blockquote><p><strong>PWA의 핵심은 서비스 워커에 있습니다.</strong> 서비스워커는 브라우저가 백그라운드에서 실행하는 스크립트로, 웹 페이지와는 별개로 작동하며 웹 페이지 또는 사용자의 인터랙션이 필요하지 않은 기능만 제공합니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/39e5c747-8a33-4fd8-bc16-1b4d85451e7e/image.png" class="img_ev3q"></p><p>서비스 워커는 브라우저와 네트워크 사이에서 <code>프록시 서버 역할</code>을 합니다. 예를 들어 브라우저에서 <code>fetch</code>요청을 했을 때 서비스 워커는 먼저 그 요청에 대한 캐시를 가지고 있는지 판단합니다.</p><p>캐시를 가지고 있다면 브라우저에 바로 캐시를 전달할 것이며, 캐시를 가지고 있지 않다면 서버에 그 요청을 보낼 것입니다. 캐싱기능을 활용함으로써 오프라인에서도 동작하는 웹을 만들 수 있습니다.</p><blockquote><p><strong>Fetch</strong>
fetch란 web resource에 접근하기 위해 행해지는 모든 <strong>request action</strong>을 의미합니다. 서비스 워커는 fetch를 통해 발생하는 모든 http request를 중간에서 가로챌 수 있습니다.(<strong>Proxy</strong>)</p></blockquote><blockquote><p>서비스 워커에서 다양한 <a href="https://github.com/team-yaza/mozi-client/wiki/Service-Worker-Caching-Strategy" target="_blank" rel="noopener noreferrer">캐싱 전략</a>을 활용할 수 있습니다.</p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/77746dad-2e5c-4c9a-9332-b6332496bc5e/image.png" class="img_ev3q"></p><p><code>manifest</code>는 json 파일입니다. 이 파일은 아래와 같이 웹 앱 설치 배너를 트리거하기위해 필요합니다. 적어주는 옵션에 따라 앱의 이름, 아이콘, 테마 색깔등을 정의할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/f3bdb180-cf28-4130-a355-8acd6f305164/image.png" class="img_ev3q"></p><p>흥미로운 부분은 manifest의 display 속성을 사용해 프로그레시브 웹 앱을 설치했을 때 브라우저에서 어떻게 보여질지 제어할 수 있다는 것입니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/90dd7e5e-569f-472d-8934-0e575e3bccd7/image.png" class="img_ev3q"></p><p>주소 막대, 뒤로가기 버튼과 같이 웹 페이지를 둘러싼 사용자 인터페이스 요소를 <code>크롬(Chrome)</code>이라고 부릅니다.</p><blockquote><p><a href="https://www.quora.com/Why-is-Google-Chrome-browser-named-as-Chrome/answer/Glen-Murphy" target="_blank" rel="noopener noreferrer">구글의 웹 브라우저는 디자인에서 크롬 요소를 줄이는 것이 의식적인 목표였는데, 그래서 역설적으로 <code>크롬</code>이라는 이름을 갖게 되었습니다.</a></p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/bec7d6cd-ae1f-444b-b260-33f3b3081448/image.png" class="img_ev3q"></p><p>display 속성을 이용해 설치된 PWA에 한하여 브라우저에서 크롬 영역을 없애거나 필요한 부분만 표시할 수 있습니다. 위와 같이 standalone이나 fullscreen 속성을 사용하면 웹 앱을 마치 네이티브 앱인 것처럼 보여지게 할 수 있습니다.</p><p>이렇게 PWA를 위해 필요한 Service Worker와 Web App Manifest에 대해 알아보았습니다. 여기에 덧붙여서 PWA의 Web Push(푸시 알림), 백그라운드 동기화와 같은 기능을 사용하면 웹에서 네이티브 앱의 기능을 사용할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/e6e1be87-aa58-4936-a8da-e45193df3ff3/image.png" class="img_ev3q"></p><p>마지막으로 소개드리고 싶은 것은 제가 개발하고 있는 <a href="https://github.com/team-yaza/mozi-client" target="_blank" rel="noopener noreferrer">MOZI</a>라는 프로젝트에서 도입한 <strong>Offline First Architecture</strong>입니다.</p><p>사용자가 애플리케이션을 사용할 때 네트워크에 연결되어 있는지 판단하는 것은 매우 어렵습니다.(가령 와이파이에는 연결된 상태인데 실제로 인터넷 접속은 되지 않는 상황) 좋지 않은 네트워크 상황에서는 웹 브라우저에 애플리케이션을 그리는데 필요한 정적 파일을 받아오는 것 또한 매우 느리게 동작할 수 있습니다.</p><p>이런 상황에 대비하기 위해 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank" rel="noopener noreferrer">Cache</a>를 사용합니다. 정적 파일들을 캐시하면 네트워크가 안좋은 상황에서 Cache에서 응답을 하기 때문에 빠르게 웹 페이지를 그릴 수 있습니다.</p><p>정적 파일들을 캐시하면 오프라인 상태에서 화면을 그릴 수는 있지만 오프라인 상태에서의 사용자와 앱의 인터랙션을 서버에 전달할 수 없습니다.</p><blockquote><p>Cache 인터페이스와 HTTP Cache는 관련이 없습니다.</p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6a4d5efb-2d4e-4744-9241-a4cca0859f81/image.png" class="img_ev3q"></p><p>오프라인 상태에서 사용자가 어떤 행동을 했는지 기록하기 위해 IndexedDB를 사용할 수 있습니다. 브라우저 기반 데이터베이스인 IndexedDB는 객제 저장소에 key-value 쌍으로된 레코드를 저장할 수 있습니다. 저장소에는 다수의 객체를 저장할 수 있는데 객체는 JavaScript 객체, 불린, 숫자, BLOB(Binary Large Object)및 JavaScript가 처리할 수 있는 대부분의 데이터 포맷 중 하나입니다.</p><p>IndexedDB는 사용자의 연결 상태와 관계없이 접근 및 조작 가능하므로 오프라인에서 사용자의 행위를 객체 형태로 저장할 수 있습니다.</p><blockquote><p>IndexedDB는 동일 출처 정책(Same-Origin Policy)를 따릅니다. 사용자는 특정 사이트에서 작성된 데이터가 다른 사이트에 노출될 것을 걱정하지 않아도 다른 사이트에 방문할 수 있습니다. 다시 말하면 자신의 도메인 내에서는 데이터를 읽고 쓸 수 있지만, 다른 도메인의 IndexedDB에 기록된 데이터는 접근할 수 없습니다.</p></blockquote><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/6da23a41-71b8-488d-a8a6-8502d2aa2cf2/image.png" class="img_ev3q"></p><p>지금까지 내용을 시각화하면 위와 같습니다. 브라우저에서 발생하는 Interaction을 객체형태로 표현해서 IndexedDB에 저장(예: Todo를 만들면 그 Todo를 객체 형태로 IndexedDB에 저장)</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/de024689-905d-4510-b600-6c0ef2d2fa85/image.png" class="img_ev3q"></p><p>IndexedDB에 데이터를 저장했으면 인터넷이 연결되면 그 데이터를 서버에 동기화 시켜줘야합니다. 이 때 PWA의 주요 기능인 <strong>백그라운드 동기화</strong>를 활용할 수 있습니다. 동기화 이벤트와 관련된 상호작용은 <code>SyncManager</code>를 통해 이루어집니다. 백그라운드 동기화는 브라우저를 닫아도 진행되기 때문에 동기화 이벤트를 등록하면(브라우저, 서버스 워커 모두에서 동기화 이벤트를 등록할 수 있습니다.) 다음과 같은 경우에 sync 이벤트를 발생시킵니다.</p><ol><li>동기화 이벤트 등록 직후</li><li>사용자 상태가 오프라인에서 온라인으로 변경될 때</li><li>성공적으로 완료되지 않은 동기화 이벤트가 있을 경우, 매 분마다</li></ol><p>이러한 백그라운드 동기화의 특성에 기반하여 오프라인에서 진행된 작업들 중 서버에 동기화되지 못한 작업들에 대하여 sync 이벤트를 등록해 놓으면 네트워크가 온라인이 되거나 또는 주기적으로 서버에 동기화하지 못한 작업에 대하여 동기화를 수행할 수 있습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/02f49d69-733f-4ca5-813f-fed7389bbc58/image.png" class="img_ev3q"></p><p>결국 Offline First Architecture는 위와 같습니다. 사용자와의 인터렉션을 서버가 아닌 IndexedDB에 저장합니다. 이때 sync 이벤트를 등록해줍니다.</p><p>sync 이벤트가 등록되면 등록된 동기화 작업이 완료될 때까지 수행합니다.</p><p>Offline First Architecture에서 중요한 부분은 데이터를 불러올 때 입니다. 데이터를 불러오는 요청을 Server에게 한 후 그 데이터를 바로 쓰는 것이 아닌 IndexedDB에 저장합니다. 그리고 IndexedDB에서 데이터를 불러옵니다.</p><p>왜 그 데이터를 바로 활용하지 않고 IndexedDB에 저장하는 과정을 거친 후에 그 데이터를 활용하는 것일까요? 저는 그 이유를 <strong>서버 상태</strong>라는 개념을 통해 설명하고 싶습니다. 서버 상태는 사용자의 제어를 벗어난 위치에서 원격으로 유지되고 소유권을 공유하기 때문에 변경될 수 있습니다. 즉 오프라인 상태에서 사용자가 IndexedDB에 조작한 데이터들은 outdated된 상태일 수 있는 것이죠.</p><p>이러한 이유로 서버 상태를 받아오면(네트워크가 연결되면) 그 상태를 IndexedDB에 저장하여 최신 상태의 데이터를 로컬에 유지할 수 있고 네트워크가 끊어지더라도 로컬에 데이터를 가지고 있기 때문에 문제가 없습니다.</p><p>또 다른 장점으로는 데이터를 가져오는 로직을 일반화할 수 있다는 것입니다. 오프라인이든 온라인이든 즉 네트워크 요청이 실패했든 성공했든간에 상관없이 우리는 데이터를 무조건 IndexedDB에서만 가져오므로 fetch 요청이 성공했는지 실패했는지 케이스 구분을 하지 않습니다. 단지 IndexedDB에서 데이터를 불러오는 것뿐입니다.</p><p>위 생각의 흐름이 제가 프로젝트에서 도입해본 <strong>Offline First Architecture</strong>에 대한 설명이었습니다.</p><p><img loading="lazy" src="https://velog.velcdn.com/images/hyunjine/post/ee28a912-7273-4f40-b0a1-dad204ace2ea/image.png" class="img_ev3q"></p><p>마지막으로 PWA에 대한 생각을 정리하며 마치겠습니다.</p><p>모든 웹 사이트는 PWA가 될 수 있습니다. PWA를 적용하면 웹사이트가 점진적으로 진화할 수 있는 가능성을 열어두고 서비스의 목적과 방향에 맞게 유동적으로 앱을 만들 수 있습니다.</p><p><strong>Make Your Web Progressive.</strong></p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/pwa">PWA</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/mozi">MOZI</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/seo"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">SEO 최적화하기</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/Sentry로-모니터링-시스템-구축하기"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Sentry로 모니터링 시스템 구축하기</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/team-yaza" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 MOZI, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1951fb87.js"></script>
<script src="/assets/js/main.c89cc93c.js"></script>
</body>
</html>